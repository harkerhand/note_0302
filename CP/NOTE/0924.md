- **词法分析** = 把源代码变成 **Token 流**（最小语义单位）
- **语法分析** = 按语言规则把 Token 流变成 **语法树 (AST)**

```c
int x = 10 + 20;
[INT] [IDENT(x)] [=] [NUMBER(10)] [+] [NUMBER(20)] [;]
```

# 语言和文法（上下文无关文法）

符号：语言中不可再分的单位 $a,b,c$

字母表：符号的非空有穷集合

符号串：某字母表上符号的有穷序列 $\alpha,\beta$

空串：$\epsilon$ 不含任何符号的串

语句：字母表上符合某种**构成规则**的符号串序列 $A,B,C$

语言：某字母表上语句的集合

闭包：$A^* = A^0 \cup A^1 ...$

正闭包：$A^+ = A^* - \{ \epsilon \}$

文法：表达语言构成规则的形式化方法

$G = (V_N, V_T, P, S)$

$V_N$：非终结符集 $V_T$：终结符集 $P$：产生式 $A \rightarrow \alpha$ $S$：文法开始符号

- 推导：使用产生式的右部取代左部的过程
    
    ```c
    Expr   → Expr "+" Term | Term
    Term   → Term "*" Factor | Factor
    Factor → "(" Expr ")" | number
    ```
    
    对于3 + 4 * 5
    
    ```c
    Expr
    → Expr "+" Term
    → Term "+" Term
    → Factor "+" Term
    → number "+" Term
    → number "+" Term "*" Factor
    → number "+" Factor "*" Factor
    → number "+" number "*" number
    ```
    
- 规约：推导的逆过程，用产生式的左部取代右部的过程
    

**最左推导和最右推导称为规范推导。 最左归约和最右归约称为规范归约。**

句型：从文法开始符号$S$开始，每步推导（包括0步推导）所得到的字符串$\alpha$

$S \rightarrow \alpha$， $\alpha \in (V_N \cup V_T)^*$ 句子：仅含终结符的句型

语言：由S推导所得的句子的集合 $L(G) = \{\alpha | S \rightarrow \alpha, \alpha \in V_T^*\}, G \text{为文法}$

文法规则的**递归**定义：非终结符的定义中包含了非终结符自身，使用递归定义时要谨慎，要有**递归出口**，否则，可能永远产生不出句子 扩充的BNF表示：

- ()：提因子 $U \rightarrow ax | ay | az \text{改写为} U \rightarrow a(x | y | z)$
- {}：指定重复次数 $\{\}_i^j$
- []：任选符号

## 形式定义

| ![](../../assets/Pasted%20image%2020251028191649.png) | ![](../../assets/Pasted%20image%2020251028191653.png) 线性界限自动机（LBA） |
| ----------------------------------------------- | ------------------------------------------------------------ |
| ![](../../assets/Pasted%20image%2020251028191657.png) | ![](../../assets/Pasted%20image%2020251028191701.png) 有限状态自动机(FSM) |


有限状态自动机(FSM)

文法简化：由于同一语言可以用不同的文法来描述，显然应当选择产生式的个数最少，最符合语言特征的来描述。

- 删除形如P→P的产生式
- 删除永不被使用的产生式，即由文法的开始符号无法推导出其左部。
- 删除不能从中导出终结符串的产生式。
- 整理产生式

![](sub/上下文无关文法)


![](../../assets/Pasted%20image%2020251028192424.png)

# 2.2.1

这个文法生成的语言是所有由 **操作数 a** 和 **二元运算符 +、*** 构成的 **合法后缀表达式**（逆波兰表达式）。

---

**更精确的描述：**

设字母表 {a,+,∗}\{a, +, *\}，则文法生成的语言 LL 包含所有满足下列条件的串：

1. 操作数 `a` 的个数 = 运算符 (`+` 或 ) 的个数 + 1。
2. 在串的任意前缀中，操作数的个数 ≥ 运算符的个数 + 1。

这两个条件正是保证后缀表达式合法的“栈高度”约束。

---

**证明思路：**

- **由文法生成 ⇒ 合法后缀式：**
    - S→aS \to a 直接生成合法表达式。
    - 若 x,yx, y 都是合法后缀式，那么 x y +x\;y\;+ 或 x y ∗x\;y\;* 依然合法。
    - 归纳可知所有由文法生成的串都是合法后缀表达式。
- **合法后缀式 ⇒ 可由文法生成：**
    - 一个合法后缀表达式末尾必然是 `+` 或 （除非它就是单个 `a`）。
    - 去掉最后一个运算符后，可以唯一划分成两个合法的子后缀表达式 x,yx, y。
    - 根据归纳假设，x,yx, y 都能由 SS 推导出。于是整个表达式由 S→S S opS \to S\;S\;op（op ∈ {+, *}）生成。

因此文法生成的语言就是：

**所有由字母 `a` 组成的操作数、以及 `+`、`*` 组成的、合法的二元运算后缀表达式。**

# 2.2.2

**a)** 
$$
S→0 S 1∣0 1S \to 0\,S\,1 \mid 0\,1。
$$
- **语言**：L={0n1n∣n≥1}L=\{0^n1^n \mid n\ge1\}。
- **理由**：基例 0 10\,1 对应 n=1n=1。每次用 S→0S1S\to0S1 在左端加一个 `0`、在右端加一个 `1`，因此可以得到任意 nn 的形式 0n1n0^n1^n。反过来每次去掉最外层的 `0`…`1` 能回退到基例，不能得到其它形式。

---

**b)** 
$$
S→+ S S∣− S S∣aS \to +\,S\,S \mid -\,S\,S \mid a。
$$
- **语言**：所有由操作数 `a` 和二元前缀运算符 `+`、 构成的**合法前缀（prefix）表达式**。
- **理由**：规则表示运算符放在两个子表达式（操作数或更复杂的表达式）之前，正是二元前缀表达式的构造法则。用 S→aS\to a 得到单个操作数，若 X,YX,Y 是合法前缀式，则 `+XY` 或 `XY` 也是合法前缀式。反过来，每个合法的前缀式最后可按最左运算符拆分为 `op` 后跟两个前缀子式，从而由该文法生成。另一个常见刻画：任何派生串满足 #a=#ops+1\#a=\#\text{ops}+1，并且满足前缀处的可归约性约束（能被解释为合法前缀式）。

---
**c)** 
$$
S→S (S) S∣εS \to S\ (S)\ S \mid \varepsilon。
$$
- **语言**：所有**平衡括号串**（Dyck 语言，允许空串）。即由左括号 `(` 与右括号 `)` 构成的所有合法配对的括号串。
- **理由**：规则 S→S (S) SS\to S\,(S)\,S 表示可以在任意位置插入一对匹配的括号，括号内外分别是任意平衡串（通过左右的 SS 表示），基础为 ε\varepsilon。这是构造所有平衡括号串的标准递归定义。

---

**d)** 
$$
S→a S b S∣b S a S∣εS \to a\,S\,b\,S \mid b\,S\,a\,S \mid \varepsilon。
$$
- **语言**：所有由字母 `a` 和 `b` 组成且 **a 的个数等于 b 的个数** 的串：{w∈{a,b}∗∣#a(w)=#b(w)}\{w\in\{a,b\}^* \mid \#a(w)=\#b(w)\}。
- **理由**：每次使用任一产生式都会同时增加一个 `a` 和一个 `b`（一个在左侧一个在右侧），基例 ε\varepsilon 计数相等为 0，因此所有产生的串满足 #a=#b\#a=\#b。反过来，可以通过归纳构造任意满足 #a=#b\#a=\#b 的串：若 ww 非空，取 ww 的首字符（是 `a` 或 `b`），向后扫描可以找到一个位置使得从首到此位置包含多于或等于的反向字母，从而按第一或第二规则把 ww 分解为形如 a x b ya\,x\,b\,y 或 b x a yb\,x\,a\,y（其中 x,yx,y 各自的 `a` 与 `b` 个数平衡），继而归纳生成。（这是常见的等数语言的文法。）

---

**e)** 
$$
S→a∣S+S∣S S∣S∗∣(S)S \to a \mid S+S \mid S\,S \mid S^* \mid (S)。
$$
（这里把文法中 `S*` 写作 S∗S^*，`S S` 表示串联/连接。）

- **语言**：所有由基本符号 `a` 通过 **并（`+`）**、**连接（串联）**、**闭包（后缀 ）** 与**圆括号**组合得到的合法**正则表达式**（仅字母表 {a}\{a\}）。换言之，这是在字母 `a` 上，用并、连接、Kleene 星与括号构造的所有正则表达式的集合。
- **理由**：产生式直接对应正则表达式的构造操作：基元 `a`；若 r,sr,s 是正则表达式，则 r+sr+s（并）和 rsr s（串联）与 r∗r^*（Kleene 星） 仍是正则表达式；括号用于分组。文法正是这些构造的形式化描述，因此生成的即是所有形式上合法的正则表达式（只含 `a`、`+`、连接、、括号）的字符串。