# 词法分析

读入源代码，输出token序列（每个单词是什么类型）

![image 1](../../assets/image%201.png)

## 正则表达式

正则表达式是定义**正规语言（Regular Language）的一种符号表示方法。它由基本符号**和**运算符**组成。

![image 1 1](../../assets/image%201%201.png)

|运算|符号|含义|举例|
|---|---|---|---|
|连接|`R1 R2`|所有由 R1 的串接上 R2 的串构成的集合|`ab` 表示 `"a"` 后跟 `"b"`|
|并（或）|`R1 \| R2`|union / alternation|匹配 R1 或 R2|
|闭包|`R*`|任意次（0 次或多次）重复 R|`a*` 表示 `""`, `"a"`, `"aa"`, ...|
|正闭包|`R+`|一次或多次重复 R|`a+` 表示 `"a"`, `"aa"`, `"aaa"`, ...|
|可选|`R?`|出现 0 或 1 次|`a?` 表示 `""` 或 `"a"`|
|范围|`[a-z]`|a-z的任何一个||

$\begin{aligned}b(ab)^* &= b \{\, \varepsilon, ab, abab, \ldots \,\} \\[6pt] &= b \{\, \varepsilon \,\} \cup b \{\, a(ba)^*b \,\} \\[6pt] &= b \;\cup\; ba(ba)^*b \\[6pt] &= \{\, \varepsilon, (ba)^+ \,\}b \\[6pt] &= (ba)^*b\end{aligned}$

数学归纳法也可

  

## 自动机

**状态图：**圆圈：状态，边：状态转化

终止状态：双圆圈；起始状态：无源输入

### 确定有穷自动机 DFA

$M = (Q, \Sigma, \delta, q_0, F)$

- 没有状态有$\epsilon$转化
    
    - 对于每个状态s和输入a，只有一条标号a的出边
    
      
    

|符号|含义|
|---|---|
|$Q$|有限状态集合（states）|
|$\Sigma$|输入字母表（alphabet）|
|$\delta$|状态转移函数（transition function）$\delta: Q \times \Sigma \to Q$|
|$q_0$|初始状态（start state），$q_0 \in Q$|
|$F$|**接受状态**（accepting states）的集合，$F \subseteq Q$|

### 非确定有穷自动机 NFA

$M = (Q, \Sigma, \delta, q_0, F)$

与 DFA 形式一样，但转移函数不同：

$\delta: Q \times (\Sigma \cup {\varepsilon}) \to 2^Q$

即：

- **NFA 可以有 ε-转移（空串转移）**
- **NFA 的转移结果是状态的集合（非确定性）**

### NFA到DFA的转化——子集构造法

构造得到的DFA的每一个状态都是NFA的一个状态集合

- 找到输入可以以$\epsilon$到达的集合，作为状态0
- 考虑状态零到字母表的转化，对转化目标集合求闭包，作为其他状态，递归

### 最小化一个DFA的状态数

通过**划分（partition）状态集合**，不断细分，直到没有状态可以再区分为止。

1. **初始划分**
    
    - 把所有状态分成两组：
        - 一组是 **接受状态**；
        - 一组是 **非接受状态**。
    
    这两组叫作初始划分 $\Pi$。
    
2. **细分划分**
    - 检查同一组内的状态，看它们在**输入相同字母**后是否转移到同一个组；
    - 如果不是，就把它们再分开；
    - 一直重复这个过程，直到划分不再改变（稳定）。
3. **合并状态**
    - 最终每一组的状态是等价的，可以合并成一个状态；
    - 这些组构成最小化后的 DFA。

![image 2](../../assets/image%202.png)