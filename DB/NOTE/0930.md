## 关系实例

一张实际的表，每一行都是一个tuple

## 属性的类型

属性有名字，所有的取值集合成为域，且通常为原子性（不可分割），如果都是原子的，称为原子域。特殊值NULL。

## 关系模式

属性的一个集合，r(R) 表示关系模式R中的一个关系r。关系没有顺序。

# 数据库

包含许多关系

## 键 Keys

表示不能重复的元素

如果 K 的值足以识别每个可能关系 r(R) 的唯一元组，则 K 是 R 的超键

如果键的真子集一定不是键，则这个键是主键

候选键：能够唯一标识表中元组的最小属性集合，主键为其中的一个

## 外键

一个引用到其他表的主键的属性

## 查询语言

用户从数据库查询信息的语言

关系代数：

|操作名称|符号|描述|示例|
|---|---|---|---|
|**选择**|$\sigma$|从关系中选择满足条件的元组|$\sigma _{age>20}(S)$|
|**投影**|$\Pi$|选择指定的属性列|$\Pi_{name,major}(S)$|
|**并集**|$\cup$|两个关系的并集（去重）|$R \cup S$|
|**差集**|$-$|属于R但不属于S的元组|$R - S$|
|**交集**|$\cap$|同时属于R和S的元组|$R \cap S$|
|**笛卡尔积**|$\times$|两个关系的所有可能组合|$R \times S$|
|**重命名**|$\rho$|重命名关系或属性|$\rho_{x(A_1,A_2)}(E)$|
|**自然连接**|$\bowtie$|使用两组关系的共有属性来合并关系|$R \times S$|
|**除法**|$\div$|找出那些在集合R中与集合S的所有元素都有对应关系的项（全覆盖）|$R \div S$|
|**赋值**|$\leftarrow$|用“赋值操作”把一个关系赋给一个临时变量|$R \leftarrow S$|
|**分组聚合**|g|获取值的集合并返回单个值作为结果|$_{branch\_name}g_{sum(balance)}(account)$|
|**外部连接**||自然连接，但保留其中一个关系的不匹配项，分为左，右，全||

**例子：**C表是{CN(course_name), Type}，S_C表是{SN(student_name), CN}

  

至少选了两门必修的学生

$\Pi_{S\_C1.SN}( \sigma_{ S\_C1.SN = S\_C2.SN \ \wedge \ S\_C1.CN \neq S\_C2.CN \ \wedge \ C1.Type = '必修' \ \wedge \ C2.Type = '必修' } (\rho_{S\_C1}(S\_C) \times \rho_{C1}(C) \times \rho_{S\_C2}(S\_C) \times \rho_{C2}(C)))$

选了所有必修的学生

$\Pi_{SN}(S\_C) - \Pi_{SN}( (\Pi_{SN}(S\_C) \times \Pi_{CN}(\sigma_{Type='必修'}(C))) - S\_C)$