| 操作名称     | 符号           | 描述                              | 示例                                         |
| -------- | ------------ | ------------------------------- | ------------------------------------------ |
| **选择**   | $\sigma$     | 从关系中选择满足条件的元组                   | $\sigma _{age>20}(S)$                      |
| **投影**   | $\Pi$        | 选择指定的属性列                        | $\Pi_{name,major}(S)$                      |
| **并集**   | $\cup$       | 两个关系的并集（去重）                     | $R \cup S$                                 |
| **差集**   | $-$          | 属于R但不属于S的元组                     | $R - S$                                    |
| **交集**   | $\cap$       | 同时属于R和S的元组                      | $R \cap S$                                 |
| **笛卡尔积** | $\times$     | 两个关系的所有可能组合                     | $R \times S$                               |
| **重命名**  | $\rho$       | 重命名关系或属性                        | $\rho_{x(A_1,A_2)}(E)$                     |
| **自然连接** | $\bowtie$    | 使用两组关系的共有属性来合并关系                | $R \times S$                               |
| **除法**   | $\div$       | 找出那些在集合R中与集合S的所有元素都有对应关系的项（全覆盖） | $R \div S$                                 |
| **赋值**   | $\leftarrow$ | 用“赋值操作”把一个关系赋给一个临时变量            | $R \leftarrow S$                           |
| **分组聚合** | g            | 获取值的集合并返回单个值作为结果                | $_{branch\_name}g_{sum(balance)}(account)$ |
| **外部连接** |              | 自然连接，但保留其中一个关系的不匹配项，分为左，右，全     |                                            |

- **删除：**$r \leftarrow r - E$ 其中E是关系代数查询
- **插入：**$r \leftarrow r \cup E$
- **更新：**$r \leftarrow E(r)$

# 结构化查询语言

$\text{关系代数} \rightarrow \text{查询语言}$

使用SQL1999

**SQL 中的域类型**

- **char(n)**：固定长度的字符串，用户指定长度 n。
- **varchar(n)**：可变长度的字符串，用户指定最大长度 n。
- **int**：整数（机器依赖的整数有限子集）。
- **smallint**：小整数（机器依赖的整数子集）。
- **numeric(p,d)**：定点数，用户指定精度 p（总位数），其中 d 位在小数点右边。
- **real, double precision**：浮点数和双精度浮点数，精度取决于机器。
- **float(n)**：浮点数，用户指定精度至少为 n 位。
- 更多类型在第 4 章介绍。

## 🧱 一、SQL 基础结构

SQL 是一种 **描述性语言（what）**，对应关系代数中的：

- **select** → 投影（π）
- **from** → 笛卡尔积（×）
- **where** → 选择（σ）

基本结构：

```SQL
SELECT A1, A2, ...
FROM R1, R2, ...
WHERE 条件;
```

结果依旧是一个**关系表**。

---

## 🧾 二、数据定义（Data Define Language）

```SQL
create table branch (
  branch_name char(15) primary key,
  branch_city char(30),
  assets integer
);

# 销毁表
drop table branch;
# 修改表结构
alter table branch add manager char(20);
```

**约束类型：**

- `not null`
- `primary key`
- `foreign key`
- `check (balance >= 0)`

---

## 🔍 三、基本查询结构（Data Manipulation Language）

### 1. select 投影

```SQL
select branch_name from loan;
select distinct branch_name from loan;
```

### 2. where 选择

```SQL
select loan_number from loan
where branch_name = 'Perryridge' and amount > 1200;
```

### 3. from 笛卡尔积 + 连接

```SQL
select customer_name, amount
from borrower, loan
where borrower.loan_number = loan.loan_number;
```

### 4. rename 别名

```SQL
select c.customer_name, l.amount
from borrower as c, loan as l
where c.loan_number = l.loan_number;
```

---

## 🧠 四、字符串与排序

```SQL
where customer_street like '%Main%'
order by customer_name desc;
```

通配符 `%` 表示任意子串，`_` 表示单个字符。

---

## ♻️ 五、集合操作（UNION / INTERSECT / EXCEPT）

|操作|说明|是否去重|
|---|---|---|
|UNION|并集|去重|
|INTERSECT|交集|去重|
|EXCEPT|差集|去重|
|加上 `ALL`|不去重||

```SQL
(select customer_name from depositor)
union
(select customer_name from borrower);
```

---

## 📊 六、聚合函数（Aggregate Functions）

|函数|含义|
|---|---|
|`AVG()`|平均值|
|`SUM()`|求和|
|`MIN()`|最小|
|`MAX()`|最大|
|`COUNT()`|计数|

例：

```SQL
select avg(balance) from account where branch_name='Perryridge';
select branch_name, count(*) from account group by branch_name;
select branch_name, avg(balance)
from account
group by branch_name
having avg(balance) > 1200;
```

---

## ⚠️ 七、空值（NULL）与三值逻辑

- `is null` / `is not null`
- `null` 与任何比较都返回 `unknown`
- where 过滤时，`unknown` 视为 `false`
- 聚合函数（除 count(*)）**忽略 null 值**

---

## 🧩 八、子查询与集合测试

### 1. in / not in（包含）

```SQL
where customer_name in (select customer_name from depositor);
```

### 2. some / all（Some可以理解为Any）

```SQL
where assets > some (select assets from branch where branch_city='Brooklyn');
where assets > all (select assets from branch where branch_city='Brooklyn');
```

### 3. exists / not exists

```SQL
select distinct S.customer_name 
from depositor as S
where not exists (
  (select branch_name 
  from branch 
  where branch_city='Brooklyn')
  except
  (select branch_name 
  from depositor, account
  where depositor.account_number = account.account_number 
  and depositor.customer_name = S.customer_name)
);
```

---

## 🧮 九、相关子查询与 unique 测试

```SQL
where unique (
  select R.customer_name
  from account, depositor as R
  where T.customer_name = R.customer_name
  and account.branch_name = 'Perryridge'
);
```

---

## 🏗 十、派生关系与 WITH 子句

### Derived Table

```SQL
select branch_name, avg_balance
from (
  select branch_name, avg(balance) as avg_balance
  from account group by branch_name
) as branch_avg
where avg_balance > 1200;
```

### With 临时视图

```SQL
with max_balance(value) as (
  select max(balance) from account
)
select account_number from account, max_balance
where account.balance = max_balance.value;
```

---

## 👁 十一、视图（View）

```SQL
create view all_customer as
(select branch_name, customer_name
 from depositor, account
 where depositor.account_number = account.account_number)
union
(select branch_name, customer_name
 from borrower, loan
 where borrower.loan_number = loan.loan_number);

select customer_name from all_customer where branch_name='Perryridge';
```

视图是**虚表**，存储定义不存数据。

---

## ✏️ 十二、数据库修改

### 插入

```SQL
insert into account values ('A-9732', 'Perryridge', 1200);
insert into account select loan_number, branch_name, 200
from loan where branch_name='Perryridge';
```

### 删除

```SQL
delete from account where branch_name='Perryridge';
```

### 更新

```SQL
update account
set balance = case
  when balance > 10000 then balance * 1.06
  else balance * 1.05
end;
```

---

## 🔗 十三、连接（JOIN）

|类型|SQL 示例|含义|
|---|---|---|
|内连接|`A join B on cond`|匹配的元组|
|左外连接|`A left outer join B`|保留 A 全部|
|右外连接|`A right outer join B`|保留 B 全部|
|全外连接|`A full outer join B`|保留两边|

例：

```SQL
select customer_name
from (depositor natural full outer join borrower)
where account_number is null or loan_number is null;
```

---

# ✅ 结论：记忆结构图

```Plain
DDL: create / alter / drop
DML: select / insert / update / delete
聚合: group by + having
集合: union / intersect / except
连接: inner / outer
子查询: in / exists / some / all
视图: create view / with
```

---

要不要我帮你出一个「这章速通总结版思维导图」？

能一张图看完所有 SQL 知识点（语法、关系代数对照、关键例题）。