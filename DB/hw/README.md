

# æ•°æ®åº“è¯¾ç¨‹è®¾è®¡

09023321 å·©çš“é”´

## èƒŒæ™¯

éšç€è®¡ç®—æœºæ•™è‚²çš„æ™®åŠä¸ç¨‹åºè®¾è®¡ç«èµ›çš„å…´èµ·ï¼Œä¼ ç»Ÿçš„â€œäººå·¥é˜…å·â€å·²æ— æ³•æ»¡è¶³é«˜æ•ˆã€å…¬æ­£çš„è¯„æµ‹éœ€æ±‚ã€‚å› æ­¤ï¼Œå¼€å‘ä¸€å¥— **OJï¼ˆOnline Judgeï¼‰åœ¨çº¿è¯„æµ‹ç³»ç»Ÿ** å…·æœ‰æ·±è¿œçš„å®é™…æ„ä¹‰ï¼š

1. **è‡ªåŠ¨åŒ–è¯„æµ‹çš„é«˜æ•ˆæ€§**ï¼šç³»ç»Ÿèƒ½å¤Ÿè‡ªåŠ¨ç¼–è¯‘ã€è¿è¡Œç”¨æˆ·æäº¤çš„ä»£ç ï¼Œå¹¶åˆ©ç”¨é¢„è®¾æµ‹è¯•ç”¨ä¾‹è¿›è¡Œæ¯«ç§’çº§çš„å³æ—¶æ¯”å¯¹ï¼Œæå¤§åœ°èŠ‚çœäº†äººåŠ›æˆæœ¬ã€‚
2. **è¯„ä»·æ ‡å‡†çš„å®¢è§‚æ€§**ï¼šé€šè¿‡ä¸¥æ ¼é™åˆ¶ **æ—¶é—´ï¼ˆCPU Timeï¼‰** ä¸ **ç©ºé—´ï¼ˆMemoryï¼‰**ï¼ŒOJ ä¸ºä»£ç æ€§èƒ½æä¾›äº†é‡åŒ–çš„ç¡¬æ€§æŒ‡æ ‡ï¼Œç¡®ä¿äº†ç»“æœçš„ç»å¯¹å…¬å¹³ã€‚
3. **äººæ‰åŸ¹å…»ä¸ç­›é€‰**ï¼šç³»ç»Ÿèƒ½å¤ŸçœŸå®è®°å½•ç”¨æˆ·çš„è§£é¢˜è¿›åº¦ä¸èƒ½åŠ›åˆ†å¸ƒï¼Œä¸ºæ•™å­¦è¯„ä¼°åŠä¼ä¸šæŠ€æœ¯äººæ‰æ‹›è˜æä¾›ç›´è§‚çš„æ•°æ®æ”¯æ’‘ã€‚

## æ¦‚å¿µæ¨¡å‹ã€æ•°æ®åº“æ¨¡å¼è®¾è®¡

### æ€»è¿°æœ¬æ•°æ®åº“

i.  æœ¬æ•°æ®åº“åŸºäºç¨‹åºè®¾è®¡ç«èµ›ä¸åœ¨çº¿è¯„æµ‹ä¸šåŠ¡å±•å¼€ã€‚æè¿°äº†ä¸åŒç±»å‹çš„èµ›äº‹ï¼Œå¦‚å›½é™…å¤§å­¦ç”Ÿç¨‹åºè®¾è®¡ç«èµ›ï¼ˆICPCï¼‰ã€ç¨‹åºè®¾è®¡åŠè¯­è¨€æœŸæœ«è€ƒè¯•ç­‰ã€‚é™¤äº†ä»¥ä¸ªäººä¸ºå•ä½å‚åŠ çš„æ¯”èµ›å¤–ï¼Œç³»ç»Ÿè¿˜æ”¯æŒä»¥ç»„ç»‡ï¼ˆå­¦é™¢ã€ç­çº§ï¼‰ä¸ºå•ä½è¿›è¡Œç®¡ç†ã€‚

ii. å¯¹äºæ‰€æœ‰æ¯”èµ›ï¼Œéƒ½ä¼šæœ‰å¤šä¸ªç«èµ›é¢˜ç›®å’Œå¤šä¸ªå‚èµ›äººå‘˜ã€‚å¯¹äºæ­£åœ¨è¿›è¡Œçš„èµ›äº‹ï¼Œç³»ç»Ÿå®æ—¶ç»Ÿè®¡æäº¤è®°å½•å¹¶ç”Ÿæˆå®æ—¶æ’åï¼›å¯¹äºå·²ç»“æŸçš„æ¯”èµ›ï¼Œè®°å½•æœ€ç»ˆè·å¥–æƒ…å†µä¸å†å²è¡¨ç°ã€‚

iii. ç»Ÿè®¡äº†é¢˜ç›®ä¸çŸ¥è¯†ç‚¹çš„å…³è”å…³ç³»ï¼Œé€šè¿‡æ ‡ç­¾ç³»ç»Ÿåˆ†ç±»ï¼ˆå¦‚ï¼šåŠ¨æ€è§„åˆ’ã€å›¾è®ºã€å­—ç¬¦ä¸²ï¼‰ï¼›ç»Ÿè®¡äº†ç”¨æˆ·åœ¨ä¸åŒé˜¶æ®µçš„è§£é¢˜è¡Œä¸ºä¸æˆé•¿è½¨è¿¹ã€‚

iv. å¯¹äºç”¨æˆ·ï¼šè®¾æœ‰åŸºæœ¬ä¿¡æ¯è¡¨ï¼ˆè´¦å·å¯†ç ï¼‰ã€æ‰€å±ç»„ç»‡ï¼ˆå­¦æ ¡/ç­çº§ï¼‰ä»¥åŠåœ¨ç³»ç»Ÿå†…çš„ç»ƒä¹ å†å²å’Œç«èµ›å‚ä¸è®°å½•ã€‚

v.  å¯¹äºç»„ç»‡æœºæ„ï¼šæ˜¯ç®¡ç†ç”¨æˆ·çš„æœ€å°è¡Œæ”¿å•ä½ï¼Œæ”¯æŒçˆ¶å­å±‚çº§ç»“æ„ï¼Œå¹¶é€šè¿‡ IP åœ°å€æ®µå…³è”åœ°ç†ä½ç½®ï¼Œç”¨äºè§„èŒƒåŒ–ç®¡ç†ã€‚

### æ•°æ®å…³ç³»

i.   ç»„ç»‡æœºæ„ï¼šåŒ…å«ç»„ç»‡ IDã€åç§°ã€ä¸Šçº§ç»„ç»‡ IDã€å¯¹åº”çš„ä½ç½® IPã€‚

ii.  ä½ç½®ä¿¡æ¯ï¼šåŒ…å« IP åœ°å€ä¸»é”®åŠå¯¹åº”çš„è¯¦ç»†ç‰©ç†åœ°å€ã€‚

iii. ç”¨æˆ·ä¿¡æ¯ï¼šå§“åã€ç™»å½•å¯†ç ã€æ‰€å±ç»„ç»‡ã€ç”¨æˆ·å”¯ä¸€ç¼–å·ã€‚

iv.  ç™»å½•æ—¥å¿—ï¼šè®°å½•ç”¨æˆ· IDã€ç™»å½•çš„å…·ä½“æ—¶é—´ã€è®¿é—®æ—¶çš„ IP åœ°å€ã€‚

v.   é¢˜ç›®ä¿¡æ¯ï¼šåŒ…å«é¢˜ç›®æè¿°ã€è¿è¡Œæ—¶é—´é™åˆ¶ï¼ˆmsï¼‰ã€å†…å­˜å ç”¨é™åˆ¶ï¼ˆMBï¼‰ã€‚

vi.  æ ‡ç­¾ç³»ç»Ÿï¼šåŒ…å«æ ‡ç­¾ IDã€çŸ¥è¯†ç‚¹åç§°ã€‚

vii. é¢˜ç›®æ ‡ç­¾å…³è”ï¼šé€šè¿‡é¢˜ç›® ID ä¸æ ‡ç­¾ ID çš„æ˜ å°„ï¼Œå®ç°ä¸€é“é¢˜ç›®å¯¹åº”å¤šä¸ªçŸ¥è¯†ç‚¹ã€‚

viii. ç«èµ›ä¿¡æ¯ï¼šåŒ…å«ç«èµ›åç§°ã€ç»Ÿä¸€çš„å¼€å§‹æ—¶é—´ä¸ç»“æŸæ—¶é—´ã€‚

ix.  ç«èµ›é¢˜ç›®å…³è”ï¼šå®šä¹‰æŸåœºç«èµ›å…·ä½“åŒ…å«å“ªäº›é¢˜ç›®åŠå…¶åœ¨æ¯”èµ›ä¸­çš„ç¼–å·ã€‚

x.   ç«èµ›å‚ä¸è€…ï¼šè®°å½•æŠ¥åæˆ–å‚åŠ æŸåœºæ¯”èµ›çš„ç”¨æˆ· ID ä¸ç«èµ› IDã€‚

xi.  æäº¤è®°å½•ï¼ˆæ ¸å¿ƒï¼‰ï¼šåŒ…å«æäº¤ç¼–å·ã€ç”¨æˆ· IDã€é¢˜ç›® IDã€æ‰€å±ç«èµ› IDã€æäº¤æ—¶é—´ã€è¿è¡Œç»“æœï¼ˆAC/WAç­‰ï¼‰ã€æ¶ˆè€—æ—¶é—´ã€æ¶ˆè€—å†…å­˜ã€‚

### ERå›¾

![ERå›¾](er.png)

### æ•°æ®åº“è®¾è®¡

- ç»„ç»‡æœºæ„
    - ç»„ç»‡ID (ä¸»é”®)
    - åç§°
    - ä¸Šçº§ç»„ç»‡ID
    - ä½ç½®IPåœ°å€
- ä½ç½®
    - ä½ç½®IP (ä¸»é”®)
    - è¯¦ç»†åœ°å€
- ç”¨æˆ·
    - ç”¨æˆ·ID (ä¸»é”®)
    - å§“å
    - å¯†ç 
    - ç»„ç»‡ID (å¤–é”®)
- ç™»å½•æ—¥å¿—
    - æ—¥å¿—ID (ä¸»é”®)
    - ç”¨æˆ·ID 
    - ç™»å½•æ—¶é—´
    - ä½ç½®IPåœ°å€
- é¢˜ç›®
    - é¢˜ç›®ID (ä¸»é”®)
    - é¢˜ç›®æè¿°
    - æ—¶é—´é™åˆ¶
    - ç©ºé—´é™åˆ¶
- æ ‡ç­¾
    - æ ‡ç­¾ID (ä¸»é”®)
    - æ ‡ç­¾åç§°
- é¢˜ç›®æ ‡ç­¾å…³è”
    - ID (ä¸»é”®)
    - é¢˜ç›®ID
    - æ ‡ç­¾ID
- æäº¤è®°å½•
    - æäº¤ID (ä¸»é”®)
    - ç”¨æˆ·ID
    - é¢˜ç›®ID
    - ç«èµ›ID
    - æäº¤æ—¶é—´
    - ç»“æœ
    - è€—æ—¶
    - ä½¿ç”¨å†…å­˜
- ç«èµ›
    - ç«èµ›ID (ä¸»é”®)
    - ç«èµ›åç§°
    - å¼€å§‹æ—¶é—´
    - ç»“æŸæ—¶é—´
- ç«èµ›é¢˜ç›®å…³è”
    - ID (ä¸»é”®)
    - ç«èµ›ID
    - é¢˜ç›®ID
- ç«èµ›å‚ä¸è€…
    - ID (ä¸»é”®)
    - ç«èµ›ID
    - ç”¨æˆ·ID

```sql
-- 1. ç»„ç»‡æœºæ„
CREATE TABLE Organization (
    OrgID INTEGER PRIMARY KEY AUTOINCREMENT,
    Name TEXT NOT NULL,
    ParentOrgID INTEGER,
    LocationIP TEXT
);

-- 2. ä½ç½®
CREATE TABLE Location (
    LocationIP TEXT PRIMARY KEY,
    Address TEXT
);

-- 3. ç”¨æˆ·
CREATE TABLE User (
    UserID INTEGER PRIMARY KEY AUTOINCREMENT,
    Username TEXT NOT NULL,
    Password TEXT NOT NULL,
    OrgID INTEGER
);

-- 4. ç™»å½•æ—¥å¿—
CREATE TABLE LoginLog (
    LogID INTEGER PRIMARY KEY AUTOINCREMENT,
    UserID INTEGER,
    LoginTime DATETIME DEFAULT CURRENT_TIMESTAMP,
    LocationIP TEXT
);

-- 5. é¢˜ç›®
CREATE TABLE Problem (
    ProblemID INTEGER PRIMARY KEY AUTOINCREMENT,
    Description TEXT,
    TimeLimit INTEGER, -- å•ä½é€šå¸¸ä¸º ms
    MemoryLimit INTEGER -- å•ä½é€šå¸¸ä¸º KB
);

-- 6. æ ‡ç­¾
CREATE TABLE Tag (
    TagID INTEGER PRIMARY KEY AUTOINCREMENT,
    TagName TEXT UNIQUE
);

-- 7. é¢˜ç›®æ ‡ç­¾å…³è” (å¤šå¯¹å¤š)
CREATE TABLE ProblemTagRelation (
    ID INTEGER PRIMARY KEY AUTOINCREMENT,
    ProblemID INTEGER,
    TagID INTEGER
);

-- 8. æäº¤è®°å½•
CREATE TABLE Submission (
    SubmissionID INTEGER PRIMARY KEY AUTOINCREMENT,
    UserID INTEGER,
    ProblemID INTEGER,
    ContestID INTEGER,
    SubmitTime DATETIME DEFAULT CURRENT_TIMESTAMP,
    Result TEXT,
    TimeUsed INTEGER,
    MemoryUsed INTEGER
);

-- 9. ç«èµ›
CREATE TABLE Contest (
    ContestID INTEGER PRIMARY KEY AUTOINCREMENT,
    ContestName TEXT,
    StartTime DATETIME,
    EndTime DATETIME
);

-- 10. ç«èµ›é¢˜ç›®å…³è”
CREATE TABLE ContestProblemRelation (
    ID INTEGER PRIMARY KEY AUTOINCREMENT,
    ContestID INTEGER,
    ProblemID INTEGER
);

-- 11. ç«èµ›å‚ä¸è€…
CREATE TABLE ContestParticipant (
    ID INTEGER PRIMARY KEY AUTOINCREMENT,
    ContestID INTEGER,
    UserID INTEGER
);
```

æ•°æ®åº“è®¾è®¡ä¸­æ²¡æœ‰ä½¿ç”¨å¤–é”®ï¼Œè€ƒè™‘åˆ°ä»¥ä¸‹å‡ ç‚¹ï¼š
- æ€§èƒ½å¼€é”€
    - å†™æ“ä½œå˜æ…¢ï¼šæ¯æ¬¡æ’å…¥ã€æ›´æ–°æˆ–åˆ é™¤æ•°æ®æ—¶ï¼Œæ•°æ®åº“å¼•æ“éƒ½å¿…é¡»å»æ‰«æå…³è”çš„è¡¨ä»¥ç¡®ä¿å­˜å®æ€§ã€‚è¿™ä¼šäº§ç”Ÿé¢å¤–çš„ç£ç›˜ I/Oã€‚

    - é”ç«äº‰ï¼šå¤–é”®çº¦æŸå¯èƒ½å¯¼è‡´æ•°æ®åº“åœ¨æ£€æŸ¥çº¦æŸæ—¶é”å®šç›¸å…³è¡¨çš„è¡Œï¼Œåœ¨é«˜å¹¶å‘åœºæ™¯ä¸‹å®¹æ˜“äº§ç”Ÿæ­»é”æˆ–ä¸¥é‡çš„é˜»å¡ã€‚

- å¼€å‘ä¸è¿ç»´çš„çµæ´»æ€§å·®

    - æ¸…ç†æ•°æ®å›°éš¾ï¼šå¦‚æœæƒ³åˆ é™¤ä¸€ä¸ªè€æ—§ç»„ç»‡ï¼Œä½†å®ƒå…³è”äº†æˆåƒä¸Šä¸‡çš„ç”¨æˆ·å’Œæ—¥å¿—ï¼Œæ•°æ®åº“ä¼šæŠ¥é”™æ‹’ç»åˆ é™¤ï¼Œå¿…é¡»æ‰‹åŠ¨å¤„ç†å¤æ‚çš„çº§è”å…³ç³»ã€‚

    - æµ‹è¯•æ•°æ®æ¨¡æ‹Ÿéš¾ï¼šåœ¨å¼€å‘é˜¶æ®µï¼Œå¦‚æœæƒ³å¿«é€Ÿä¼ªé€ å‡ æ¡â€œæäº¤è®°å½•â€è¿›è¡ŒUIæµ‹è¯•ï¼Œå¤–é”®ä¼šå¼ºè¿«å¿…é¡»å…ˆåˆ›å»ºå¯¹åº”çš„â€œç”¨æˆ·â€å’Œâ€œé¢˜ç›®â€ï¼Œå¢åŠ äº†å¼€å‘å¿ƒæ™ºè´Ÿæ‹…ã€‚

- çº§è”åˆ é™¤çš„é£é™©
    - å¤–é”®æ”¯æŒçº§è”åˆ é™¤ã€‚è™½ç„¶æ–¹ä¾¿ï¼Œä½†æå…¶å±é™©ã€‚ä¸€æ—¦è¯¯æ“ä½œåˆ é™¤äº†ä¸€ä¸ªçˆ¶èŠ‚ç‚¹ï¼Œå¯èƒ½ä¼šå¯¼è‡´æ•´ä¸ªå…³è”é“¾è·¯çš„æ•°æ®ç¬é—´è¢«ç‰©ç†æŠ¹é™¤ï¼Œéš¾ä»¥æ¢å¤ã€‚

### å…¸å‹ä»»åŠ¡åœºæ™¯

- æŸ¥è¯¢æ‰€æœ‰æ ‡ç­¾åç§°ä¸º â€œEasyâ€ çš„é¢˜ç›® ID

$\Pi_{ProblemID}(\sigma_{TagName='Easy'}(Tag \bowtie ProblemTagRelation))$

- æŸ¥è¯¢ç”¨æˆ· ID ä¸º 10 çš„æ‰€æœ‰æäº¤ç»“æœå’Œè€—æ—¶

$\Pi_{Result, TimeUsed}(\sigma_{UserID=10}(Submission))$

- æŸ¥è¯¢åœ¨â€œåŒ—äº¬â€åœ°å€ï¼ˆLocationIP å…³è”ï¼‰ç™»å½•è¿‡çš„ç”¨æˆ·å

$\Pi_{Username}(User \bowtie LoginLog \bowtie \sigma_{Address='åŒ—äº¬'}(Location))$

- æŸ¥è¯¢å‚åŠ äº† ID ä¸º 100 çš„ç«èµ›çš„æ‰€æœ‰ç”¨æˆ· ID

$\Pi_{UserID}(\sigma_{ContestID=100}(ContestParticipant))$

- æŸ¥è¯¢å†…å­˜é™åˆ¶å¤§äº 128MB (131072 KB) çš„é¢˜ç›®æè¿°

$\Pi_{Description}(\sigma_{MemoryLimit > 131072}(Problem))$

- æŸ¥æ‰¾æ²¡æœ‰ä¸Šçº§æœºæ„ï¼ˆæ ¹æœºæ„ï¼‰çš„æœºæ„åç§°

$\Pi_{Name}(\sigma_{ParentOrgID = NULL}(Organization))$

-  æŸ¥è¯¢ç«èµ›â€œ2023 Finalâ€åŒ…å«çš„æ‰€æœ‰é¢˜ç›® ID

$\Pi_{ProblemID}(ContestProblemRelation \bowtie \sigma_{ContestName='2023 Final'}(Contest))$

- æŸ¥è¯¢ä»æœªè¿›è¡Œè¿‡ä»»ä½•æäº¤çš„ç”¨æˆ· ID

$\Pi_{UserID}(User) - \Pi_{UserID}(Submission)$

- æŸ¥è¯¢é¢˜ç›® ID ä¸º 5 ä¸”ç»“æœä¸º 'Accepted' çš„æ‰€æœ‰æäº¤ ID

$\Pi_{SubmissionID}(\sigma_{ProblemID=5 \land Result='Accepted'}(Submission))$

- æŸ¥è¯¢åŒæ—¶åŒ…å«æ ‡ç­¾ ID 1 å’Œæ ‡ç­¾ ID 2 çš„é¢˜ç›® ID

$\Pi_{ProblemID}(\sigma_{TagID=1}(ProblemTagRelation)) \cap \Pi_{ProblemID}(\sigma_{TagID=2}(ProblemTagRelation))$

- å‚åŠ äº†æ‰€æœ‰ç«èµ›çš„ç”¨æˆ· IDï¼ˆé™¤æ³•è¿ç®—ï¼‰

$\Pi_{UserID, ContestID}(ContestParticipant) Ã· \Pi_{ContestID}(Contest)$

- æŸ¥è¯¢è§£å†³äº†ç«èµ› ID ä¸º 100 çš„â€œæ‰€æœ‰â€é¢˜ç›®çš„ç”¨æˆ· ID

$$\Pi_{UserID, ProblemID}(Submission \bowtie \sigma_{Result='Accepted'}(Submission)) \div \Pi_{ProblemID}(\sigma_{ContestID=100}(ContestProblemRelation))$$

- æŸ¥è¯¢ä»æœªåœ¨è‡ªå·±æ‰€å±ç»„ç»‡æ‰€åœ¨çš„ IP åœ°å€ç™»å½•è¿‡çš„ç”¨æˆ· ID

$$\Pi_{UserID}(User) - \Pi_{UserID}(User \bowtie_{\text{User.OrgID = Org.OrgID}} Organization \bowtie_{\text{Org.LocationIP = Log.LocationIP}} LoginLog)$$

- æŸ¥è¯¢è‡³å°‘å‚åŠ è¿‡ä¸¤åœºä¸åŒç«èµ›çš„ç”¨æˆ· ID

$$\Pi_{C_1.UserID}(\sigma_{C_1.UserID = C_2.UserID \land C_1.ContestID \neq C_2.ContestID}(C_1 \times C_2))$$

- æŸ¥è¯¢å±äºâ€œäºŒçº§æœºæ„â€çš„ç”¨æˆ·æäº¤è¿‡çš„é¢˜ç›® ID

$$\Pi_{ProblemID}(Submission \bowtie User \bowtie \sigma_{ParentOrgID \neq NULL}(Organization))$$

- æŸ¥è¯¢æ‰€æœ‰åŒ…å«â€œåŠ¨æ€è§„åˆ’â€æ ‡ç­¾ä½†ä¸åŒ…å«â€œæ•°å­¦â€æ ‡ç­¾çš„é¢˜ç›® ID

$$\Pi_{ProblemID}(ProblemTagRelation \bowtie \sigma_{TagName='åŠ¨æ€è§„åˆ’'}(Tag)) - \Pi_{ProblemID}(ProblemTagRelation \bowtie \sigma_{TagName='æ•°å­¦'}(Tag))$$

- æŸ¥è¯¢åœ¨æ‰€æœ‰ç™»å½•è¿‡çš„ä½ç½®ä¸­ï¼Œè‡³å°‘æœ‰ä¸€ä¸ªä½ç½®æ˜¯â€œä¸Šæµ·â€çš„ç”¨æˆ·å§“å

$$\Pi_{Username}(User \bowtie LoginLog \bowtie \sigma_{Address='ä¸Šæµ·'}(Location))$$

- æŸ¥è¯¢é‚£äº›â€œæ‰€æœ‰æäº¤è®°å½•å‡ä¸º Acceptedâ€çš„ç”¨æˆ· ID

$$\Pi_{UserID}(Submission) - \Pi_{UserID}(\sigma_{Result \neq 'Accepted'}(Submission))$$

-  æŸ¥è¯¢é‚£äº›åœ¨ç«èµ›æœŸé—´ä¹‹å¤–å¯¹ç«èµ›é¢˜ç›®è¿›è¡Œæäº¤çš„ç”¨æˆ· ID

$$\Pi_{UserID}(\sigma_{SubmitTime < StartTime \lor SubmitTime > EndTime}(Submission \bowtie Contest \bowtie ContestProblemRelation))$$

## SQLæŸ¥è¯¢ã€æ•°æ®åº“æ¨¡å¼ä¼˜åŒ–å’Œå®ç°

### å…¸å‹ä»»åŠ¡åœºæ™¯çš„ SQL è¡¨è¾¾

-  æŸ¥è¯¢æ‰€æœ‰æ ‡ç­¾åç§°ä¸º â€œEasyâ€ çš„é¢˜ç›® ID 

```sql
SELECT DISTINCT R.ProblemID 
FROM Tag T JOIN ProblemTagRelation R ON T.TagID = R.TagID
WHERE T.TagName = 'Easy';
```

- æŸ¥è¯¢ç”¨æˆ· ID ä¸º 10 çš„æ‰€æœ‰æäº¤ç»“æœå’Œè€—æ—¶

```sql
SELECT Result, TimeUsed 
FROM Submission 
WHERE UserID = 10;
```

- æŸ¥è¯¢åœ¨â€œåŒ—äº¬â€åœ°å€ç™»å½•è¿‡çš„ç”¨æˆ·å

```sql
SELECT DISTINCT U.Username 
FROM User U 
JOIN LoginLog L ON U.UserID = L.UserID 
JOIN Location LOC ON L.LocationIP = LOC.LocationIP
WHERE LOC.Address = 'åŒ—äº¬';
```

- æŸ¥è¯¢å‚åŠ äº† ID ä¸º 100 çš„ç«èµ›çš„æ‰€æœ‰ç”¨æˆ· ID

```sql
SELECT UserID 
FROM ContestParticipant 
WHERE ContestID = 100;
```

- æŸ¥è¯¢å†…å­˜é™åˆ¶å¤§äº 128MB (131072 KB) çš„é¢˜ç›®æè¿°


```sql
SELECT Description 
FROM Problem 
WHERE MemoryLimit > 131072;
```

- æŸ¥æ‰¾æ²¡æœ‰ä¸Šçº§æœºæ„ï¼ˆæ ¹æœºæ„ï¼‰çš„æœºæ„åç§°


```sql
SELECT Name 
FROM Organization 
WHERE ParentOrgID IS NULL;
```


- æŸ¥è¯¢ç«èµ›â€œ2023 Finalâ€åŒ…å«çš„æ‰€æœ‰é¢˜ç›® ID


```sql
SELECT R.ProblemID 
FROM ContestProblemRelation R JOIN Contest C ON R.ContestID = C.ContestID
WHERE C.ContestName = '2023 Final';
```

- æŸ¥è¯¢ä»æœªè¿›è¡Œè¿‡ä»»ä½•æäº¤çš„ç”¨æˆ· IDï¼ˆå·®è¿ç®—ï¼‰

```sql
SELECT UserID FROM User
EXCEPT
SELECT UserID FROM Submission;
```

- æŸ¥è¯¢é¢˜ç›® ID ä¸º 5 ä¸”ç»“æœä¸º 'Accepted' çš„æ‰€æœ‰æäº¤ ID


```sql
SELECT SubmissionID 
FROM Submission 
WHERE ProblemID = 5 AND Result = 'Accepted';
```

- æŸ¥è¯¢åŒæ—¶åŒ…å«æ ‡ç­¾ ID 1 å’Œæ ‡ç­¾ ID 2 çš„é¢˜ç›® 

```sql
SELECT ProblemID FROM ProblemTagRelation WHERE TagID = 1
INTERSECT
SELECT ProblemID FROM ProblemTagRelation WHERE TagID = 2;
```


- æŸ¥è¯¢å‚åŠ äº†æ‰€æœ‰ç«èµ›çš„ç”¨æˆ· ID

```sql
SELECT UserID 
FROM User U
WHERE NOT EXISTS (
    SELECT ContestID FROM Contest
    EXCEPT
    SELECT ContestID FROM ContestParticipant CP WHERE CP.UserID = U.UserID
);
```

- æŸ¥è¯¢è§£å†³äº†ç«èµ› ID ä¸º 100 çš„â€œæ‰€æœ‰â€é¢˜ç›®çš„ç”¨æˆ· ID

```sql
SELECT S.UserID 
FROM Submission S
WHERE S.Result = 'Accepted' 
AND S.ProblemID IN (SELECT ProblemID FROM ContestProblemRelation WHERE ContestID = 100)
GROUP BY S.UserID
HAVING COUNT(DISTINCT S.ProblemID) = (SELECT COUNT(*) FROM ContestProblemRelation WHERE ContestID = 100);
```

- æŸ¥è¯¢ä»æœªåœ¨è‡ªå·±æ‰€å±ç»„ç»‡æ‰€åœ¨çš„ IP åœ°å€ç™»å½•è¿‡çš„ç”¨æˆ· ID


```sql
SELECT UserID FROM User
EXCEPT
SELECT U.UserID 
FROM User U 
JOIN Organization O ON U.OrgID = O.OrgID 
JOIN LoginLog L ON U.UserID = L.UserID AND O.LocationIP = L.LocationIP;
```

- æŸ¥è¯¢è‡³å°‘å‚åŠ è¿‡ä¸¤åœºä¸åŒç«èµ›çš„ç”¨æˆ· ID

```sql
SELECT DISTINCT C1.UserID 
FROM ContestParticipant C1, ContestParticipant C2 
WHERE C1.UserID = C2.UserID AND C1.ContestID != C2.ContestID;
```


- æŸ¥è¯¢å±äºâ€œäºŒçº§æœºæ„â€çš„ç”¨æˆ·æäº¤è¿‡çš„é¢˜ç›® ID


```sql
SELECT DISTINCT S.ProblemID 
FROM Submission S 
JOIN User U ON S.UserID = U.UserID 
JOIN Organization O ON U.OrgID = O.OrgID
WHERE O.ParentOrgID IS NOT NULL;
```

- æŸ¥è¯¢åŒ…å«â€œåŠ¨æ€è§„åˆ’â€ä½†ä¸åŒ…å«â€œæ•°å­¦â€æ ‡ç­¾çš„é¢˜ç›® ID

```sql
SELECT R.ProblemID FROM ProblemTagRelation R JOIN Tag T ON R.TagID = T.TagID WHERE T.TagName = 'åŠ¨æ€è§„åˆ’'
EXCEPT
SELECT R.ProblemID FROM ProblemTagRelation R JOIN Tag T ON R.TagID = T.TagID WHERE T.TagName = 'æ•°å­¦';
```

- æŸ¥è¯¢åœ¨æ‰€æœ‰ç™»å½•ä½ç½®ä¸­ï¼Œè‡³å°‘æœ‰ä¸€ä¸ªä½ç½®æ˜¯â€œä¸Šæµ·â€çš„ç”¨æˆ·å§“å

```sql
SELECT DISTINCT U.Username 
FROM User U 
JOIN LoginLog L ON U.UserID = L.UserID 
JOIN Location LOC ON L.LocationIP = LOC.LocationIP
WHERE LOC.Address = 'ä¸Šæµ·';
```

- æŸ¥è¯¢é‚£äº›â€œæ‰€æœ‰æäº¤è®°å½•å‡ä¸º Acceptedâ€çš„ç”¨æˆ· ID

```sql
SELECT UserID FROM Submission
EXCEPT
SELECT UserID FROM Submission WHERE Result != 'Accepted';
```

- æŸ¥è¯¢åœ¨ç«èµ›æœŸé—´ä¹‹å¤–å¯¹ç«èµ›é¢˜ç›®è¿›è¡Œæäº¤çš„ç”¨æˆ· ID

```sql
SELECT DISTINCT S.UserID 
FROM Submission S 
JOIN Contest C ON S.ContestID = C.ContestID
JOIN ContestProblemRelation CPR ON S.ProblemID = CPR.ProblemID AND C.ContestID = CPR.ContestID
WHERE S.SubmitTime < C.StartTime OR S.SubmitTime > C.EndTime;
```


### æ•°æ®åº“æ¨¡å¼è®¾è®¡è¯„ä»·ä¸ä¼˜åŒ–

è™½ç„¶ç›®å‰çš„è¡¨ç»“æ„å·²ç»åŸºæœ¬æ‹†åˆ†ï¼Œä½†ä»å­˜åœ¨ä»¥ä¸‹æ½œåœ¨é£é™©ï¼š

1. **æ›´æ–°å¼‚å¸¸**ï¼šåœ¨ `Organization` è¡¨ä¸­ï¼Œå¦‚æœ `LocationIP` å‘ç”Ÿå˜æ›´ï¼ˆä¾‹å¦‚æŸä¸ªæ ¡åŒºæ›´æ¢äº†å‡ºå£ IPï¼‰ï¼Œç”±äº `Location` æè¿°ä¾èµ–äº IPï¼Œè‹¥ä¸æ…åœ¨ `Organization` ä¸­ä¿®æ”¹äº† IP è€ŒæœªåŒæ­¥ `Location` è¡¨ï¼ˆæˆ–åä¹‹ï¼‰ï¼Œä¼šå¯¼è‡´é€»è¾‘åœ°å€ä¸ç‰©ç†åœ°å€è„±èŠ‚ã€‚

    ä¼˜åŒ–æ–¹æ¡ˆï¼šæ·»åŠ LocationIDåšä¸»é”®ã€‚

    ```sql
    -- 1. ç»„ç»‡æœºæ„
    CREATE TABLE Organization (
        OrgID INTEGER PRIMARY KEY AUTOINCREMENT,
        Name TEXT NOT NULL,
        ParentOrgID INTEGER,
        LocationID INTEGER
    );
    
    -- 2. ä½ç½®
    CREATE TABLE Location (
        LocationID INTEGER PRIMARY KEY AUTOINCREMENT,
        LocationIP TEXT,
        Address TEXT
    );
    
    -- 4. ç™»å½•æ—¥å¿—
    CREATE TABLE LoginLog (
        LogID INTEGER PRIMARY KEY AUTOINCREMENT,
        UserID INTEGER,
        LoginTime DATETIME DEFAULT CURRENT_TIMESTAMP,
        LocationID INTEGER
    );
    ```

    

2. **åˆ é™¤ä¸æ’å…¥å¼‚å¸¸**ï¼šé€šè¿‡ä¸è®¾ç½®å¤–é”®å·²ç»é¿å…ï¼Œé€»è¾‘äº¤ç”±åº”ç”¨å¤„ç†ã€‚

### å‡½æ•°ä¾èµ–é›†

- **Organization (ç»„ç»‡æœºæ„)**
    - $OrgID \to \{Name, ParentOrgID, LocationID\}$
    - *è¯´æ˜ï¼šé€šè¿‡ç»„ç»‡ ID å¯ä»¥å”¯ä¸€ç¡®å®šç»„ç»‡åç§°ã€çˆ¶çº§ç»„ç»‡åŠå…³è”çš„ä½ç½® IDã€‚*
- **Location (ä½ç½®ä¿¡æ¯)**
    - $LocationID \to \{LocationIP, Address\}$
    - *è¯´æ˜ï¼šå¼•å…¥è‡ªå¢ ID åï¼ŒIP åœ°å€ä¸å†ä½œä¸ºä¸»é”®ï¼Œè€Œæ˜¯ä½œä¸ºå±æ€§ç”± LocationID å†³å®šã€‚*
- **User (ç”¨æˆ·)**
    - $UserID \to \{Username, Password, OrgID\}$
- **LoginLog (ç™»å½•æ—¥å¿—)**
    - $LogID \to \{UserID, LoginTime, LocationID\}$
- **Problem (é¢˜ç›®)**
    - $ProblemID \to \{Description, TimeLimit, MemoryLimit\}$
- **Submission (æäº¤è®°å½•)**
    - $SubmissionID \to \{UserID, ProblemID, ContestID, SubmitTime, Result, TimeUsed, MemoryUsed\}$
- **Contest (ç«èµ›)**
    - $ContestID \to \{ContestName, StartTime, EndTime\}$
- **Tag (æ ‡ç­¾)**
    - $TagID \to TagName$


### å…³äºèŒƒå¼çš„è®ºè¯

é€šè¿‡å•ä¸»å±æ€§ä¸æ¶ˆç­å¤–é”®ï¼Œå¾ˆæ˜¾ç„¶çš„åšåˆ°äº†â€œå¯¹äºæ¯ä¸€ä¸ªéå¹³å‡¡çš„å‡½æ•°ä¾èµ–ï¼Œå‰ä»¶éƒ½æ˜¯å€™é€‰é”®â€ï¼Œæ‰€ä»¥è¾¾åˆ°BCNFã€‚

- ä¼˜ç‚¹

    - **å½»åº•æ¶ˆé™¤æ›´æ–°å¼‚å¸¸**ï¼šæ— è®º IP åœ°å€å¦‚ä½•å˜åŠ¨ï¼Œæˆ–æŸä¸ªç‰©ç†ä½ç½®çš„åç§°ï¼ˆå¦‚â€œå®éªŒæ¥¼â€æ›´åä¸ºâ€œå›¾çµæ¥¼â€ï¼‰å¦‚ä½•ä¿®æ”¹ï¼Œéƒ½**åªéœ€æ›´æ–°ä¸€å¤„**ã€‚

    - **æ•°æ®é›¶å†—ä½™**ï¼šæ¯ä¸ªäº‹å®ï¼ˆå¦‚åœ°ç†ä½ç½®ã€ç»„ç»‡ä¿¡æ¯ã€ç”¨æˆ·ä¿¡æ¯ï¼‰åœ¨æ•°æ®åº“ä¸­åªå‡ºç°ä¸€æ¬¡ï¼Œæå¤§åœ°èŠ‚çœäº†å­˜å‚¨ç©ºé—´å¹¶é™ä½äº†æ•°æ®ä¸ä¸€è‡´çš„é£é™©ã€‚

    - **ç»“æ„æ¸…æ™°**ï¼šè¡¨çš„åŠŸèƒ½é«˜åº¦è§£è€¦ï¼Œ`Location` è´Ÿè´£ç‰©ç†ç©ºé—´ï¼Œ`Organization` è´Ÿè´£è¡Œæ”¿é€»è¾‘ï¼Œç¬¦åˆè½¯ä»¶å·¥ç¨‹çš„â€œé«˜å†…èšä½è€¦åˆâ€åŸåˆ™ã€‚

- ç¼ºç‚¹

    - **æŸ¥è¯¢æ€§èƒ½æŸè€—ï¼ˆJoin è¾ƒå¤šï¼‰**ï¼šç”±äºæ•°æ®åˆ†æ•£ï¼ŒæŸ¥è¯¢ä¸€ä¸ªç”¨æˆ·çš„ç™»å½•ç‰©ç†åœ°å€éœ€è¦è¿›è¡Œ $User \bowtie Organization \bowtie Location$ ä¸‰è¡¨è¿æ¥ã€‚åœ¨é«˜å¹¶å‘çš„ OJ å®æ—¶æ’åæŸ¥è¯¢ä¸­ï¼Œè¿æ¥æ“ä½œä¼šå¸¦æ¥é¢å¤–çš„ CPU å¼€é”€ã€‚

    - **ç´¢å¼•ç»´æŠ¤æˆæœ¬**ï¼šä¸ºäº†ä¿è¯ä¸‰è¡¨è¿æ¥çš„é€Ÿåº¦ï¼Œå¿…é¡»åœ¨ `OrgID`ã€`LocationID` ç­‰æ‰€æœ‰å¤–é”®å…³è”å­—æ®µä¸Šå»ºç«‹ç´¢å¼•ï¼Œè¿™ä¼šç¨å¾®å¢åŠ ç£ç›˜å ç”¨å’Œæ’å…¥æ•°æ®çš„è€—æ—¶ã€‚

    - **å¼€å‘å¤æ‚åº¦å¢åŠ **ï¼šåœ¨åç«¯ä»£ç ä¸­ï¼Œä¸èƒ½ç›´æ¥ä» `User` å¯¹è±¡è·å– `Address`ï¼Œå¿…é¡»ç¼–å†™æ›´å¤æ‚çš„å…³è”æŸ¥è¯¢æˆ–åœ¨ä»£ç å±‚è¿›è¡Œå¤šæ¬¡æŸ¥è¯¢ã€‚

### ç´¢å¼•ä¼˜åŒ–åçš„SQL

æ³¨ï¼šåŒæ—¶æ”¹ä¸º MySql é£æ ¼ï¼ŒåŠ å…¥æ›´å¤šNOT NULLçº¦æŸ

```sql
-- 1. ä½ç½®è¡¨
CREATE TABLE IF NOT EXISTS Location
(
    LocationID INT PRIMARY KEY AUTO_INCREMENT,
    LocationIP VARCHAR(45)  NOT NULL, -- ä½¿ç”¨ VARCHAR(45) ä»¥å…¼å®¹ IPv6
    Address    VARCHAR(255) NOT NULL,
    UNIQUE INDEX idx_unique_ip (LocationIP)
) ENGINE = InnoDB;

-- 2. ç»„ç»‡æœºæ„è¡¨
CREATE TABLE IF NOT EXISTS Organization
(
    OrgID       INT PRIMARY KEY AUTO_INCREMENT,
    Name        VARCHAR(100) NOT NULL,
    ParentOrgID INT,
    LocationID  INT          NOT NULL,
    INDEX idx_org_parent (ParentOrgID),
    INDEX idx_org_location (LocationID)
) ENGINE = InnoDB;

-- 3. ç”¨æˆ·è¡¨
CREATE TABLE IF NOT EXISTS User
(
    UserID   INT PRIMARY KEY AUTO_INCREMENT,
    Username VARCHAR(50)  NOT NULL UNIQUE,
    Password VARCHAR(255) NOT NULL,
    OrgID    INT,
    INDEX idx_user_org (OrgID)
) ENGINE = InnoDB;

-- 4. ç™»å½•æ—¥å¿—è¡¨
CREATE TABLE IF NOT EXISTS LoginLog
(
    LogID      INT PRIMARY KEY AUTO_INCREMENT,
    UserID     INT NOT NULL,
    LoginTime  DATETIME DEFAULT CURRENT_TIMESTAMP,
    LocationID INT NOT NULL,
    INDEX idx_log_user (UserID),
    INDEX idx_log_location (LocationID)
) ENGINE = InnoDB;

-- 5. é¢˜ç›®è¡¨
CREATE TABLE IF NOT EXISTS Problem
(
    ProblemID   INT PRIMARY KEY AUTO_INCREMENT,
    Description TEXT NOT NULL,
    TimeLimit   INT,
    MemoryLimit INT
) ENGINE = InnoDB;

-- 6. æ ‡ç­¾è¡¨
CREATE TABLE IF NOT EXISTS Tag
(
    TagID   INT PRIMARY KEY AUTO_INCREMENT,
    TagName VARCHAR(50) UNIQUE NOT NULL
) ENGINE = InnoDB;

-- 7. é¢˜ç›®æ ‡ç­¾å…³è”è¡¨
CREATE TABLE IF NOT EXISTS ProblemTagRelation
(
    ID        INT PRIMARY KEY AUTO_INCREMENT,
    ProblemID INT NOT NULL,
    TagID     INT NOT NULL,
    INDEX idx_ptr_problem (ProblemID),
    INDEX idx_ptr_tag (TagID)
) ENGINE = InnoDB;

-- 8. æäº¤è®°å½•è¡¨
CREATE TABLE IF NOT EXISTS Submission
(
    SubmissionID INT PRIMARY KEY AUTO_INCREMENT,
    UserID       INT                                NOT NULL,
    ProblemID    INT                                NOT NULL,
    ContestID    INT,
    SubmitTime   DATETIME DEFAULT CURRENT_TIMESTAMP NOT NULL,
    Result       VARCHAR(20),
    TimeUsed     INT                                NOT NULL,
    MemoryUsed   INT                                NOT NULL,
    INDEX idx_sub_user (UserID),
    INDEX idx_sub_contest_problem (ContestID, ProblemID),
    INDEX idx_sub_result (Result)
) ENGINE = InnoDB;

-- 9. ç«èµ›è¡¨
CREATE TABLE IF NOT EXISTS Contest
(
    ContestID   INT PRIMARY KEY AUTO_INCREMENT,
    ContestName VARCHAR(100) NOT NULL,
    StartTime   DATETIME,
    EndTime     DATETIME
) ENGINE = InnoDB;

-- 10. ç«èµ›é¢˜ç›®å…³è”è¡¨
CREATE TABLE IF NOT EXISTS ContestProblemRelation
(
    ID        INT PRIMARY KEY AUTO_INCREMENT,
    ContestID INT NOT NULL,
    ProblemID INT NOT NULL,
    INDEX idx_cpr_contest (ContestID)
) ENGINE = InnoDB;

-- 11. ç«èµ›å‚ä¸è€…è¡¨
CREATE TABLE IF NOT EXISTS ContestParticipant
(
    ID        INT PRIMARY KEY AUTO_INCREMENT,
    ContestID INT NOT NULL,
    UserID    INT NOT NULL,
    INDEX idx_cp_contest_user (ContestID, UserID)
) ENGINE = InnoDB;
```

## Web æ¶æ„å®ç°

ä½¿ç”¨MySQL8.0æ•°æ®åº“ï¼Œä½¿ç”¨Rustä½œä¸ºåç«¯ï¼ŒVueä½œä¸ºå‰ç«¯

ç¨‹åºä¸»è¦åˆ†ä¸ºä¸¤éƒ¨åˆ†ï¼š

- **SQLæŸ¥è¯¢éƒ¨åˆ†**ï¼šå‰ç«¯ä¼šå‘é€ç”¨æˆ·çš„SQLè¯·æ±‚åˆ°åç«¯ï¼Œç”±åç«¯ä¸æ•°æ®åº“äº¤äº’åè¿”å›å¹¶å±•ç¤º
- **ç°ä»£æŸ¥è¯¢æ–¹å¼æ¼”ç¤º**ï¼šåç«¯ä¼šä½¿ç”¨ç°ä»£è¯­è¨€ä¸å·¥å…·çš„ç‰¹æ€§å¯¹æ•°æ®åº“è¿›è¡Œä¾¿æ·è®¿é—®ï¼Œå‰ç«¯åªéœ€è¦é€šè¿‡ç‰¹å®šæ¥å£å³å¯è·å–æ•°æ®

### å‰ç«¯æ¼”ç¤º

è¿›å…¥ç½‘é¡µåå¦‚å›¾æ‰€ç¤ºï¼Œå·¦è¾¹çš„æ–‡æœ¬æ¡†å¯ä»¥è¿›è¡ŒSQLè¯­å¥çš„ç¼–å†™ï¼Œ

![image-20251221082056721](./README/image-20251221082056721.png)

ç‚¹å‡»å·¦ä¸‹è§’çš„ç¤ºä¾‹æŒ‰é’®å¯ä»¥å¿«é€Ÿå¡«å……SQLæ–‡æœ¬æ¡†ï¼Œç‚¹å‡»è¿è¡ŒæŸ¥è¯¢å³å¯æŸ¥è¯¢å¹¶åœ¨å³è¾¹å±•ç¤ºæŸ¥è¯¢ç»“æœï¼Œ

![image-20251221082315816](./README/image-20251221082315816.png)

å³ä¸Šè§’çš„æŒ‰é’®æ˜¯è°ƒç”¨åç«¯æä¾›çš„APIæ¥è¿›è¡ŒæŸ¥è¯¢ï¼Œæ›´åŠ ç°ä»£ä¸å®‰å…¨ã€‚

![image-20251221082350997](./README/image-20251221082350997.png)

### æ•°æ®åº“äº¤äº’è¯´æ˜

å¯¹äºå¸¸è§„çš„SQLè¯­å¥è½¬å‘è¯·æ±‚ï¼Œåç«¯ä¸»è¦è¿›è¡Œæ ¼å¼è½¬æ¢çš„å·¥ä½œï¼Œå› ä¸ºäº‹å…ˆä¸å¯é¢„çŸ¥æŸ¥è¯¢çš„æ•°æ®è¡¨æ ·å¼ï¼Œå¯¹äºRustè¿™ç±»å¼ºç±»å‹è¯­è¨€æ¥è¯´è¾ƒä¸ºç¹ç

```rust
async fn handle_query(
    axum::extract::State(pool): axum::extract::State<MySqlPool>,
    Json(payload): Json<SqlRequest>,
) -> Json<serde_json::Value> {
    match sqlx::query(&payload.sql).fetch_all(&pool).await {
        Ok(rows) => {
            let mut results = Vec::new();
            for row in rows {
                let mut map = serde_json::Map::new();
                for column in row.columns() {
                    let name = column.name();
                    let value = if let Ok(v) = row.try_get::<String, _>(name) {
                        serde_json::Value::String(v)
                    } else if let Ok(v) = row.try_get::<i64, _>(name) {
                        serde_json::Value::Number(v.into())
                    } else if let Ok(v) = row.try_get::<f64, _>(name) {
                        serde_json::Number::from_f64(v)
                            .map(serde_json::Value::Number)
                            .unwrap_or(serde_json::Value::Null)
                    } else if let Ok(v) = row.try_get::<bool, _>(name) {
                        serde_json::Value::Bool(v)
                    } else if let Ok(v) = row.try_get::<chrono::NaiveDateTime, _>(name) {
                        serde_json::Value::String(v.to_string())
                    } else {
                        serde_json::Value::Null
                    };
                    map.insert(name.to_string(), value);
                }
                results.push(serde_json::Value::Object(map));
            }
            Json(serde_json::json!(results))
        }
        Err(e) => Json(serde_json::json!({ "error": e.to_string() })),
    }
}
```

ç„¶è€Œç°ä»£è¯­è¨€åŠå·¥å…·å¯ä»¥æ–¹ä¾¿çš„å°†æ•°æ®åº“æ˜ å°„åˆ°æ•°æ®ç»“æ„ï¼Œä¾‹å¦‚ä¸‹é¢çš„ä»£ç ï¼Œå¯¹äºå·²çŸ¥è¿”å›ç»“æ„çš„æŸ¥è¯¢ï¼Œå¯ä»¥å°†å…¶ç»‘å®šåˆ°ç‰¹å®šçš„æ•°æ®ç»“æ„ä¸­ï¼Œå¹¶ä¸”ç°ä»£å·¥å…·å¯ä»¥ä½¿ç”¨çµæ´»çš„å½¢å¼è¿›è¡Œæ•°æ®åº“çš„è®¿é—®ï¼Œä¾‹å¦‚ï¼šåœ¨Rustè¯­è¨€ä¸­ï¼Œå¸¸å¸¸ä½¿ç”¨è›‡å½¢å‘½åæ³•ï¼Œä½†æ•°æ®åº“ä¸­ä¸æ˜¯ï¼Œæ‰€ä»¥sqlxå·¥å…·æä¾›äº†renameæ³¨è§£ï¼Œä¿æŒäº†è¯­è¨€è‡ªå·±çš„ç‰¹è‰²ï¼ŒåŒæ—¶è§£å†³äº†è®¿é—®æ•°æ®åº“æ—¶å­—æ®µåç§°ä¸ä¸€è‡´çš„é—®é¢˜ï¼›å¦å¤–ï¼Œè¿™ç§å½¢å¼ä¹Ÿå¯ä»¥å¯¹å‰ç«¯å±è”½éƒ¨åˆ†æ•æ„Ÿæ•°æ®ã€‚

```rust
#[derive(Serialize, FromRow)]
pub struct User {
    #[sqlx(rename = "UserID")] // åŒ¹é…æ•°æ®åº“çš„å¤§å†™åˆ—å
    pub id: i32,
    #[sqlx(rename = "Username")]
    pub username: String,
    #[allow(dead_code)]
    #[serde(skip_serializing)] // æ•æ„Ÿä¿¡æ¯ä¸è¿”å›ç»™å‰ç«¯
    #[sqlx(rename = "Password")]
    pub password: String,
    #[sqlx(rename = "OrgID")]
    pub org_id: Option<i32>,
}
// è·å–æ‰€æœ‰ç”¨æˆ·
pub async fn get_users(State(pool): State<MySqlPool>) -> Json<serde_json::Value> {
    match sqlx::query_as::<_, User>("SELECT * FROM User")
        .fetch_all(&pool)
        .await
    {
        Ok(users) => Json(serde_json::json!(users)),
        Err(e) => Json(serde_json::json!({ "error": e.to_string() })),
    }
}
```

## åˆ—å­˜å‚¨æ¨¡å¼è®¾è®¡

### B+æ ‘è®¾è®¡

- è¡¨çš„æ¯ä¸€åˆ—å•ç‹¬å­˜å‚¨ä¸ºä¸€ä¸ªæ–‡ä»¶

- å¯¹äºæ¯ä¸€åˆ—ï¼Œå­˜å‚¨å…¶å€¼ä¸å¯¹åº”çš„è¡Œå·

- å¯¹äºæ¯ä¸ªåˆ—ï¼Œåˆ›å»ºç‹¬ç«‹B+æ ‘ï¼Œæ¯ä¸ªèŠ‚ç‚¹å­˜å‚¨åˆ—å€¼ä¸è¡Œå·ï¼Œå…¶ä¸­åˆ—å€¼ä¸ºé”®

- å»ºç«‹è¡Œå·åˆ°B+æ ‘èŠ‚ç‚¹æŒ‡é’ˆçš„ç´¢å¼•è¡¨

- æŸ¥è¯¢æ“ä½œï¼šäºŒåˆ†å®šä½åˆ°å¯¹åº”çš„èŠ‚ç‚¹ï¼Œéå†å…¶è¡Œå·è¿›è¡ŒæŸ¥è¯¢

- æ’å…¥æ“ä½œï¼šäºŒåˆ†å®šä½åˆ°å¯¹åº”çš„èŠ‚ç‚¹ï¼Œå¦‚å­˜åœ¨ï¼Œæ–°å¢è¡Œå·ï¼Œå¦‚ä¸å­˜åœ¨ï¼Œæ–°å¢èŠ‚ç‚¹ï¼›æ›´æ–°ç´¢å¼•è¡¨

- åˆ é™¤æ“ä½œï¼šä½¿ç”¨ç´¢å¼•è¡¨æ‰¾åˆ°å¯¹åº”èŠ‚ç‚¹ï¼Œåˆ é™¤å…¶å†…çš„è¡Œå·ï¼Œåˆ é™¤åå¦‚æœæ— è¡Œå·ï¼Œåˆ™åˆ é™¤èŠ‚ç‚¹

### å…³ç³»åˆ°æ–‡ä»¶æ˜ å°„

- ä¸€ä¸ªå…³ç³»å¯¹åº”ä¸€ä¸ªæ–‡ä»¶å¤¹
- ä¸€åˆ—å¯¹åº”ä¸€ä¸ªæ–‡ä»¶

### ä¼ªä»£ç 

- æ•°æ®ç»“æ„è¯´æ˜

    ```rust
    // é€»è¾‘è¡Œå·ç±»å‹
    type RowID = u64;
    
    // æ¯ä¸€åˆ—å¯¹åº”ä¸€ä¸ªç‰©ç†æ–‡ä»¶æ˜ å°„
    struct ColumnStore<K> {
        // å­˜å‚¨åˆ—å€¼åˆ°è¡Œå·çš„æ˜ å°„ï¼ˆB+æ ‘ï¼‰
        bplus_tree: BPlusTree<K, Vec<RowID>>,
        // æ–¹ä¾¿é€šè¿‡ RowID å¿«é€Ÿå®šä½å¹¶åˆ é™¤æ•°æ®
        rid_index: HashMap<RowID, LeafNodePointer>,
        // æ¯ä¸€åˆ—ç‹¬ç«‹çš„æ–‡ä»¶å¥æŸ„
        file_handle: File,
    }
    ```

- æŸ¥è¯¢

    ```rust
    impl<K: Ord> ColumnStore<K> {
        // ç‚¹æŸ¥è¯¢ï¼šæŸ¥æ‰¾ç‰¹å®šå€¼çš„æ‰€æœ‰è¡Œå·
        fn point_query(&self, target_value: K) -> Vec<RowID> {
            // 1. äºŒåˆ†å®šä½ï¼šåœ¨B+æ ‘ä¸­æœç´¢è¯¥é”®
            let leaf_node = self.bplus_tree.find_leaf(target_value);
            
            if let Some(node) = leaf_node {
                // 2. éå†è¯¥èŠ‚ç‚¹çš„é”®å€¼å¯¹ï¼Œæ‰¾åˆ°åŒ¹é…çš„ RowID é›†åˆ
                if let Some(rids) = node.get_row_ids_for_key(target_value) {
                    return rids.clone();
                }
            }
            vec![] // æœªæ‰¾åˆ°
        }
    
        // èŒƒå›´æŸ¥è¯¢ï¼šäºŒåˆ†å®šä½èµ·ç‚¹ï¼Œç„¶åæ¨ªå‘éå†
        fn range_query(&self, min_v: K, max_v: K) -> Vec<RowID> {
            let mut results = Vec::new();
            // 1. å®šä½åˆ°åŒ…å« min_v çš„èµ·å§‹å¶å­èŠ‚ç‚¹
            let mut curr_node = self.bplus_tree.find_leaf(min_v);
    
            while let Some(node) = curr_node {
                for (key, rids) in node.iter_pairs() {
                    if key > max_v { return results; } // è¶…è¿‡èŒƒå›´
                    if key >= min_v {
                        results.extend(rids);
                    }
                }
                // 2. æ²¿ç€ B+ æ ‘å¶å­èŠ‚ç‚¹çš„å…„å¼ŸæŒ‡é’ˆç§»åŠ¨
                curr_node = node.next_sibling;
            }
            results
        }
    }
    ```

    - æ’å…¥æ“ä½œ

        ```rust
        impl<K: Ord> ColumnStore<K> {
            fn insert(&mut self, value: K, row_id: RowID) {
                // 1. äºŒåˆ†å®šä½åˆ°å¶å­èŠ‚ç‚¹
                let (leaf_ptr, node) = self.bplus_tree.find_leaf_mut(value);
        
                if node.contains_key(value) {
                    // æƒ…å†µ A: é”®å­˜åœ¨ï¼Œç›´æ¥åœ¨ç°æœ‰èŠ‚ç‚¹æ–°å¢è¡Œå·
                    node.add_rid_to_key(value, row_id);
                } else {
                    // æƒ…å†µ B: é”®ä¸å­˜åœ¨ï¼Œæ–°å¢èŠ‚ç‚¹ï¼ˆæˆ–åœ¨èŠ‚ç‚¹å†…æ–°å¢é”®ï¼‰
                    node.insert_new_key(value, row_id);
                    // å¦‚æœèŠ‚ç‚¹æ»¡äº†ï¼Œæ‰§è¡Œ B+ æ ‘åˆ†è£‚é€»è¾‘
                    if node.is_full() {
                        self.bplus_tree.split_and_rebalance(leaf_ptr);
                    }
                }
        
                // 2. å…³é”®æ­¥éª¤ï¼šæ›´æ–°è¡Œå·ç´¢å¼•è¡¨ï¼Œè®°å½•è¯¥ RowID æ‰€åœ¨çš„èŠ‚ç‚¹æŒ‡é’ˆ
                self.rid_index.insert(row_id, leaf_ptr);
            }
        }
        ```

    - åˆ é™¤æ“ä½œ

        ```rust
        impl<K: Ord> ColumnStore<K> {
            fn delete(&mut self, value: K, row_id: RowID) {
                // 1. æŸ¥æ‰¾ç´¢å¼•è¡¨ï¼šç›´æ¥è·å–è¯¥è¡Œå·æ‰€åœ¨çš„ B+ æ ‘èŠ‚ç‚¹æŒ‡é’ˆ
                if let Some(leaf_ptr) = self.rid_index.get(&row_id) {
                    let node = self.bplus_tree.get_mut_node(leaf_ptr);
        
                    // 2. åœ¨è¯¥èŠ‚ç‚¹å†…ç§»é™¤è¡Œå·
                    node.remove_rid(value, row_id);
        
                    // 3. æ£€æŸ¥ï¼šå¦‚æœè¯¥ Key ä¸‹æ²¡æœ‰æ›´å¤šè¡Œå·
                    if node.get_rids_count(value) == 0 {
                        node.remove_key(value); // å½»åº•ç§»é™¤è¯¥é”®
                        
                        // 4. B+ æ ‘ç»´æŠ¤ï¼šå¦‚æœèŠ‚ç‚¹å› åˆ é™¤è€Œè¿‡ç©ºï¼Œæ‰§è¡Œåˆå¹¶é€»è¾‘
                        if node.is_underflow() {
                            self.bplus_tree.coalesce_or_redistribute(leaf_ptr);
                        }
                    }
                    
                    // 5. ä»ç´¢å¼•è¡¨ä¸­ç§»é™¤è¯¥è¡Œè®°å½•
                    self.rid_index.remove(&row_id);
                }
            }
        }
        ```

        ### æ›´å¤šæ€è€ƒ

        ä¸Šå‡åˆ°å…³ç³»å±‚çº§æ—¶ï¼Œåˆ—å­˜å‚¨æ¨¡å¼çš„æ“ä½œé€»è¾‘æœ‰æ›´å¤šçš„æŒ‘æˆ˜ï¼Œä¸»è¦æ˜¯å¦‚ä½•ä¿æŒä¸åŒåˆ—æ–‡ä»¶ä¹‹é—´ RowID çš„ä¸¥æ ¼åŒæ­¥ã€‚

        å¯ä»¥è®¾è®¡ï¼š

        - å…ƒæ•°æ®ç®¡ç†å™¨ï¼šç»´æŠ¤è¡¨ç»“æ„ï¼Œè®°å½•è¯¥è¡¨åŒ…å«å“ªäº›åˆ—ï¼Œä»¥åŠæ¯åˆ—å¯¹åº”çš„ç‰©ç†æ–‡ä»¶è·¯å¾„ã€‚
        - è¡Œå·åè°ƒå™¨ï¼šç¡®ä¿æ’å…¥æ–°è¡Œæ—¶ï¼Œæ‰€æœ‰åˆ—ä½¿ç”¨ç›¸åŒçš„é€»è¾‘ RowIDã€‚
        - è¡Œå·ç´¢å¼•è¡¨ï¼šç°åœ¨éœ€è¦ç®¡ç† `RowID -> {ColA_NodePtr, ColB_NodePtr, ...}` çš„æ˜ å°„ã€‚

        **ä¼ªä»£ç å¦‚ä¸‹ï¼š**

        - å…³ç³»ç‚¹æŸ¥è¯¢

        ```rust
        impl Relation {
            fn select(&self, projection: Vec<ColID>, condition_col: ColID, value: K) -> ResultSet {
                // 1. åœ¨è¿‡æ»¤åˆ—çš„ B+ æ ‘ä¸­è¿›è¡Œç‚¹æŸ¥è¯¢ï¼Œè·å–åŒ¹é…çš„ RowID é›†åˆ
                let target_rids = self.columns[condition_col].point_query(value);
                
                let mut final_results = ResultSet::new();
        
                // 2. æ ¹æ®è·å–çš„ RowIDï¼Œåˆ†åˆ«å»ç›®æ ‡åˆ—ä¸­æå–æ•°æ®
                for rid in target_rids {
                    let mut row_data = Row::new();
                    for &col_id in &projection {
                        let val = self.columns[col_id].get_value_by_rid(rid);
                        row_data.push(val);
                    }
                    final_results.add_row(row_data);
                }
                final_results
            }
        }
        ```

        - å…³ç³»æ’å…¥

        ```rust
        impl Relation {
            fn insert_row(&mut self, new_row: HashMap<ColID, Value>) -> Result<(), Error> {
                // 1. ç”Ÿæˆå…¨å±€å”¯ä¸€çš„é€’å¢è¡Œå·
                let new_rid = self.generate_next_rid();
        
                // 2. éå†è¡¨ä¸­æ‰€æœ‰åˆ—ï¼ŒåŒæ­¥æ‰§è¡Œæ’å…¥
                for (col_id, col_index) in self.columns.iter_mut() {
                    let val = new_row.get(col_id).expect("Schema mismatch");
                    col_index.insert(val, new_rid);
                }
                
                Ok(())
            }
        }
        ```

        - å…³ç³»åˆ é™¤

        ```rust
        impl Relation {
            fn delete_rows(&mut self, condition_col: ColID, value: K) {
                // 1. æ‰¾åˆ°æ‰€æœ‰éœ€è¦åˆ é™¤çš„ RowIDs
                let rids_to_delete = self.columns[condition_col].point_query(value);
        
                // 2. çº§è”åˆ é™¤ï¼šä»æ‰€æœ‰åˆ—æ–‡ä»¶ä¸­ç§»é™¤è¿™äº›è¡Œ
                for rid in rids_to_delete {
                    for col_index in self.columns.values_mut() {
                        col_index.delete_by_rid(rid);
                    }
                }
            }
        }
        ```

        **ä¼˜åŠ¿ä¸æŒ‘æˆ˜ï¼š**

        - ä¼˜åŠ¿ï¼šæŠ•å½±æ•ˆç‡

        ç”±äºæ˜¯åˆ—å­˜å‚¨ï¼Œå¦‚æœä¸€ä¸ªè¡¨æœ‰ 100 åˆ—ï¼ŒæŸ¥è¯¢åªæ¶‰åŠ 2 åˆ—ï¼Œè¯¥å…³ç³»æŸ¥è¯¢åªä¼šæ‰“å¼€ 2 ä¸ªåˆ—æ–‡ä»¶ã€‚ç›¸æ¯”è¡Œå­˜éœ€è¦è¯»å–æ•´è¡Œå†æŠ›å¼ƒæ— æ•ˆå­—æ®µï¼Œè®¾è®¡åœ¨ I/O ä¸ŠèŠ‚çœäº† **98%** çš„å¼€é”€ã€‚

        - æŒ‘æˆ˜ï¼šå†™æ”¾å¤§

        ç”±äºæ¯ä¸€åˆ—éƒ½æœ‰è‡ªå·±çš„ B+ æ ‘å’Œç´¢å¼•è¡¨ï¼Œæ’å…¥ä¸€è¡Œæ•°æ®ä¼šå¯¼è‡´å¤šæ¬¡ç£ç›˜éšæœº IOï¼ˆæ¯ä¸ªåˆ—æ–‡ä»¶éƒ½è¦æ›´æ–°ï¼‰ã€‚æˆ–è®¸å¯ä»¥å¼•å…¥ç¼“å†²æ± ï¼šä¸ç›´æ¥ä¿®æ”¹ç£ç›˜ä¸Šçš„ B+ æ ‘ï¼Œè€Œæ˜¯å…ˆå°†æ–°è¡Œç¼“å­˜åœ¨å†…å­˜ä¸­ï¼Œç­‰ç§¯ç´¯åˆ°ä¸€å®šæ•°é‡åï¼Œå†æ‰¹é‡åˆ·å…¥ç£ç›˜ã€‚

        ## é™„å½•

### å‰ç«¯æ ¸å¿ƒä»£ç 

```vue
<template>
  <div class="sql-dashboard">
    <header class="navbar">
      <div class="logo">
        <span class="icon">âš¡</span>
        <span class="text">OJ SQL Lab</span>
      </div>
      <div class="status-bar">
        <span class="status-dot"></span>
        Backend: Online
      </div>
    </header>

    <main class="content-wrapper">
      <section class="editor-pane">
        <div class="pane-header">SQL è¯·æ±‚ç¼–è¾‘å™¨</div>
        <div class="textarea-container">
          <textarea 
            v-model="sql" 
            spellcheck="false"
            placeholder="Write your SQL here..."
          ></textarea>
        </div>
        
        <button @click="runQuery" :disabled="loading" class="run-button">
          {{ loading ? 'æ‰§è¡Œä¸­...' : 'è¿è¡ŒæŸ¥è¯¢' }}
        </button>

        <div class="examples-section">
          <div class="pane-header">ä¸€é”®ç¤ºä¾‹</div>
          <div class="example-grid">
            <div 
              v-for="(item, idx) in examples" 
              :key="idx" 
              @click="sql = item.code"
              class="example-card"
            >
              {{ item.title }}
            </div>
          </div>
        </div>
      </section>

      <section class="result-pane">
        <div class="pane-header">ä¸€é”®æ‰“å°</div>
        <div class="button-group">
          <button 
            v-for="(btn, idx) in button_groups" 
            :key="idx" 
            @click="fetchNative(btn.type)" 
            :disabled="loading" 
            class="run-button"
          >
            {{ btn.title }}
          </button>
        </div>
        <div class="pane-header">
          æŸ¥è¯¢ç»“æœ
          <span v-if="results.length" class="count-tag">{{ results.length }} rows</span>
        </div>
        
        <div class="table-container">
          <div v-if="error" class="error-box">
            <span class="error-title">SQL Error:</span>
            <p>{{ error }}</p>
          </div>

          <table v-else-if="results.length > 0">
            <thead>
              <tr>
                <th v-for="key in Object.keys(results[0])" :key="key">{{ key }}</th>
              </tr>
            </thead>
            <tbody>
              <tr v-for="(row, i) in results" :key="i">
                <td v-for="(val, j) in Object.values(row)" :key="j">
                  <span :class="{ 'null-val': val === null }">
                    {{ val === null ? 'NULL' : val }}
                  </span>
                </td>
              </tr>
            </tbody>
          </table>

          <div v-else class="empty-state">
            <div class="empty-icon">ğŸ“‚</div>
            <p>æ²¡æœ‰æ•°æ®ï¼Œæ‰§è¡ŒæŸ¥è¯¢ä»¥æŸ¥çœ‹ç»“æœã€‚</p>
          </div>
        </div>
      </section>
    </main>
  </div>
</template>

<script setup>
import { ref } from 'vue'

const sql = ref('-- ä¾‹ï¼šæŸ¥æ‰¾æ‰€æœ‰ç”¨æˆ·\nSELECT * FROM User;')
const results = ref([])
const error = ref(null)
const loading = ref(false)

const examples = [
  { title: "Easyé¢˜ç›®", code: "SELECT DISTINCT R.ProblemID FROM Tag T JOIN ProblemTagRelation R ON T.TagID = R.TagID WHERE T.TagName = 'Easy';" },
  { title: "ç”¨æˆ·æäº¤æƒ…å†µ", code: "SELECT Result, TimeUsed FROM Submission WHERE UserID = 10;" },
  { title: "åŒ—äº¬ç™»å½•ç”¨æˆ·", code: "SELECT DISTINCT U.Username FROM User U JOIN LoginLog L ON U.UserID = L.UserID JOIN Location LOC ON L.LocationID = LOC.LocationID WHERE LOC.Address = 'åŒ—äº¬';" },
  { title: "ç«èµ›å‚åŠ è€…", code: "SELECT UserID FROM ContestParticipant WHERE ContestID = 1;" },
  { title: "å†…å­˜é™åˆ¶æŸ¥è¯¢", code: "SELECT Description FROM Problem WHERE MemoryLimit > 131072;" },
  { title: "æ ¹æœºæ„æŸ¥è¯¢", code: "SELECT Name FROM Organization WHERE ParentOrgID IS NULL;" },
  { title: "ç«èµ›é¢˜ç›®", code: "SELECT R.ProblemID FROM ContestProblemRelation R JOIN Contest C ON R.ContestID = C.ContestID WHERE C.ContestName = '2023 Final';" },
  { title: "æœªæäº¤ç”¨æˆ·", code: "SELECT UserID FROM User EXCEPT SELECT UserID FROM Submission;" },
  { title: "é€šè¿‡æäº¤", code: "SELECT SubmissionID FROM Submission WHERE ProblemID = 1 AND Result = 'Accepted';" },
  { title: "äº¤é›†æ ‡ç­¾", code: "SELECT ProblemID FROM ProblemTagRelation WHERE TagID = 1 INTERSECT SELECT ProblemID FROM ProblemTagRelation WHERE TagID = 3;" },
  { title: "å…¨ç«èµ›å‚åŠ è€…", code: "SELECT UserID FROM User U WHERE NOT EXISTS (SELECT ContestID FROM Contest EXCEPT SELECT ContestID FROM ContestParticipant CP WHERE CP.UserID = U.UserID);" },
  { title: "ç«èµ›å…¨é€š", code: "SELECT S.UserID FROM Submission S WHERE S.Result = 'Accepted' AND S.ProblemID IN (SELECT ProblemID FROM ContestProblemRelation WHERE ContestID = 1) GROUP BY S.UserID HAVING COUNT(DISTINCT S.ProblemID) = (SELECT COUNT(*) FROM ContestProblemRelation WHERE ContestID = 1);" },
  { title: "å¼‚åœ°ç™»å½•", code: "SELECT UserID FROM User EXCEPT SELECT U.UserID FROM User U JOIN Organization O ON U.OrgID = O.OrgID JOIN LoginLog L ON U.UserID = L.UserID AND O.LocationID = L.LocationID;" },
  { title: "å¤šç«èµ›å‚åŠ ", code: "SELECT DISTINCT C1.UserID FROM ContestParticipant C1, ContestParticipant C2 WHERE C1.UserID = C2.UserID AND C1.ContestID != C2.ContestID;" },
  { title: "äºŒçº§æœºæ„é¢˜ç›®", code: "SELECT DISTINCT S.ProblemID FROM Submission S JOIN User U ON S.UserID = U.UserID JOIN Organization O ON U.OrgID = O.OrgID WHERE O.ParentOrgID IS NOT NULL;" },
  { title: "æ ‡ç­¾å·®é›†", code: "SELECT R.ProblemID FROM ProblemTagRelation R JOIN Tag T ON R.TagID = T.TagID WHERE T.TagName = 'åŠ¨æ€è§„åˆ’' EXCEPT SELECT R.ProblemID FROM ProblemTagRelation R JOIN Tag T ON R.TagID = T.TagID WHERE T.TagName = 'æ•°å­¦';" },
  { title: "ä¸Šæµ·ç™»å½•ç”¨æˆ·", code: "SELECT DISTINCT U.Username FROM User U JOIN LoginLog L ON U.UserID = L.UserID JOIN Location LOC ON L.LocationID = LOC.LocationID WHERE LOC.Address = 'ä¸Šæµ·';" },
  { title: "å…¨é€šç”¨æˆ·", code: "SELECT UserID FROM Submission EXCEPT SELECT UserID FROM Submission WHERE Result != 'Accepted';" },
  { title: "ç«èµ›å¤–æäº¤", code: "SELECT DISTINCT S.UserID FROM Submission S JOIN Contest C ON S.ContestID = C.ContestID JOIN ContestProblemRelation CPR ON S.ProblemID = CPR.ProblemID AND C.ContestID = CPR.ContestID WHERE S.SubmitTime < C.StartTime OR S.SubmitTime > C.EndTime;" }
]

const button_groups = [
  { title: "ç”¨æˆ·", type: "users" },
  { title: "æœºæ„", type: "organizations" },
  { title: "ç«èµ›", type: "contests" },
  { title: "æ ‡ç­¾", type: "tags" },
  { title: "æ—¥å¿—", type: "login_logs" },
  { title: "ä½ç½®", type: "locations" },
  { title: "é¢˜ç›®", type: "problems" },
  { title: "æäº¤", type: "submissions" },
  { title: "é¢˜ç›®-æ ‡ç­¾", type: "problem_tag_relations" },
  { title: "ç«èµ›-é¢˜ç›®", type: "contest_problem_relations" },
  { title: "ç«èµ›-ç”¨æˆ·", type: "contest_participants" }
]

async function runQuery() {
  loading.value = true
  error.value = null
  try {
    const res = await fetch('http://localhost:3000/api/query', {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({ sql: sql.value })
    })
    const data = await res.json()
    if (data.error) error.value = data.error
    else results.value = data
  } catch (err) {
    error.value = "Failed to connect to Rust backend at localhost:3000"
  } finally {
    loading.value = false
  }
}

// Vue ç«¯çš„è°ƒç”¨é€»è¾‘
async function fetchNative(type) {
  loading.value = true;
  error.value = null;
  try {
    const res = await fetch(`http://localhost:3000/api/${type}`);
    const data = await res.json();
    if (data.error) error.value = data.error;
    else results.value = data; // ç»“æ„ä½“è¿”å›çš„ JSON æ•°ç»„ç›´æ¥èµ‹å€¼ç»™è¡¨æ ¼å³å¯
  } catch (err) {
    error.value = "Connect failed";
  } finally {
    loading.value = false;
  }
}
</script>

<style scoped>
/* åŸºç¡€é‡ç½® */
.sql-dashboard {
  height: 100vh;
  display: flex;
  flex-direction: column;
  font-family: 'Inter', -apple-system, BlinkMacSystemFont, sans-serif;
  background-color: #0f172a;
  color: #f1f5f9;
}

/* é¡¶éƒ¨å¯¼èˆª */
.navbar {
  height: 60px;
  background-color: #1e293b;
  display: flex;
  align-items: center;
  justify-content: space-between;
  padding: 0 24px;
  border-bottom: 1px solid #334155;
}
.logo { display: flex; align-items: center; gap: 10px; font-weight: 800; font-size: 1.2rem; color: #38bdf8; }
.status-bar { font-size: 0.85rem; color: #94a3b8; display: flex; align-items: center; gap: 8px; }
.status-dot { width: 8px; height: 8px; background: #22c55e; border-radius: 50%; box-shadow: 0 0 8px #22c55e; }

/* ä¸»ä½“å¸ƒå±€ */
.content-wrapper {
  flex: 1;
  display: flex;
  overflow: hidden; /* å…³é”®ï¼šé˜²æ­¢æ•´ä½“å‡ºç°æ»šåŠ¨æ¡ */
}

/* æ ‡é¢˜æ ·å¼ */
.pane-header {
  padding: 12px 16px;
  font-size: 0.75rem;
  font-weight: 700;
  color: #ffffff;
  letter-spacing: 0.05em;
  background: #0f172a;
  border-radius: 10px;
}

/* å·¦ä¾§ç¼–è¾‘å™¨ */
.editor-pane {
  width: 400px;
  border-right: 1px solid #334155;
  display: flex;
  flex-direction: column;
  padding: 16px;
  background: #1e293b;
}
.textarea-container { flex: 1; min-height: 200px; align-items: center; display: flex; justify-content: center; margin-top: 16px; }
textarea {
  width: 90%;
  height: 80%;
  background: #0f172a;
  border: 1px solid #334155;
  border-radius: 8px;
  color: #e2e8f0;
  padding: 16px;
  font-family: 'Fira Code', 'Monaco', monospace;
  font-size: 0.9rem;
  resize: none;
  outline: none;
}
textarea:focus { border-color: #38bdf8; }

.run-button {
  margin-top: 16px;
  padding: 14px;
  background: #38bdf8;
  color: #0f172a;
  border: none;
  border-radius: 8px;
  font-weight: 700;
  cursor: pointer;
  transition: all 0.2s;
}
.run-button:hover { background: #7dd3fc; transform: translateY(-1px); }
.run-button:disabled { background: #475569; cursor: not-allowed; }

.examples-section {
  flex: 1;
  overflow: auto;
  padding: 16px;
  scrollbar-width: thin;
  scrollbar-color: #475569 #1e293b;
}

.example-grid {
  display: grid;
  grid-template-columns: 1fr 1fr;
  gap: 8px;
  margin-top: 8px;
}
.example-card {
  padding: 10px;
  background: #334155;
  border-radius: 6px;
  font-size: 0.75rem;
  cursor: pointer;
  text-align: center;
  transition: background 0.2s;
}
.example-card:hover { background: #475569; color: #38bdf8; }

/* å³ä¾§ç»“æœé›† */
.result-pane {
  flex: 1;
  display: flex;
  flex-direction: column;
  background: #0f172a;
}
.table-container {
  flex: 1;
  overflow: auto; /* å…è®¸è¡¨æ ¼å†…éƒ¨æ»šåŠ¨ */
  padding: 0 16px 16px 16px;
  scrollbar-width: thin;
  scrollbar-color: #475569 #1e293b;
}

table {
  width: 100%;
  border-collapse: collapse;
  font-size: 0.85rem;
  color: #cbd5e1;
}
th {
  position: sticky; /* è¡¨å¤´å¸é¡¶ */
  top: 0;
  background: #1e293b;
  text-align: left;
  padding: 12px;
  border-bottom: 2px solid #334155;
  z-index: 10;
}
td {
  padding: 12px;
  border-bottom: 1px solid #1e293b;
}
tr:hover { background: #1e293b; }

.null-val { color: #64748b; font-style: italic; }
.count-tag { margin-left: 10px; color: #38bdf8; }

/* çŠ¶æ€å±•ç¤º */
.error-box {
  background: #451a1a;
  border: 1px solid #7f1d1d;
  padding: 16px;
  border-radius: 8px;
  color: #fca5a5;
}
.error-title { font-weight: bold; display: block; margin-bottom: 8px; }

.empty-state {
  height: 100%;
  display: flex;
  flex-direction: column;
  align-items: center;
  justify-content: center;
  color: #64748b;
}
.empty-icon { font-size: 3rem; margin-bottom: 16px; }

.button-group {
  display: flex;
  padding: 0 10px;
  gap: 8px;
}
.button-group .run-button {
  flex: 1;
}


</style>
```

### åç«¯æ ¸å¿ƒä»£ç 

```rust
// main.rs
mod model;

use crate::model::{get_contest_participants, get_contest_problem_relations, get_contests, get_locations, get_login_logs, get_organizations, get_problem_tags, get_problems, get_submissions, get_tags, get_users};
use axum::routing::get;
use axum::{routing::post, Json, Router};
use serde::Deserialize;
use sqlx::mysql::MySqlPool;
use sqlx::{Column, Row};
use std::net::SocketAddr;
use tower_http::cors::CorsLayer;

#[derive(Deserialize)]
struct SqlRequest {
    sql: String,
}

#[tokio::main]
async fn main() {
    let database_url = "harkerhand://harkerhand:harkerhand@10.210.126.58/oj_db";
    let pool = MySqlPool::connect(database_url).await.unwrap();

    let app = Router::new()
        .route("/api/query", post(handle_query))
        .route("/api/users", get(get_users))
        .route("/api/submissions", get(get_submissions))
        .route("/api/organizations", get(get_organizations))
        .route("/api/contests", get(get_contests))
        .route("/api/tags", get(get_tags))
        .route("/api/login_logs", get(get_login_logs))
        .route("/api/locations", get(get_locations))
        .route("/api/problems", get(get_problems))
        .route("/api/problem_tag_relations", get(get_problem_tags))
        .route("/api/contest_problem_relations", get(get_contest_problem_relations))
        .route("/api/contest_participants", get(get_contest_participants))
        .layer(CorsLayer::permissive()) // å…è®¸è·¨åŸŸ
        .with_state(pool);

    let addr = SocketAddr::from(([127, 0, 0, 1], 3000));
    println!("ç›‘å¬ç«¯å£: {}", addr);
    let listener = tokio::net::TcpListener::bind(addr).await.unwrap();
    axum::serve(listener, app).await.unwrap();
}

async fn handle_query(
    axum::extract::State(pool): axum::extract::State<MySqlPool>,
    Json(payload): Json<SqlRequest>,
) -> Json<serde_json::Value> {
    match sqlx::query(&payload.sql).fetch_all(&pool).await {
        Ok(rows) => {
            let mut results = Vec::new();
            for row in rows {
                let mut map = serde_json::Map::new();
                for column in row.columns() {
                    let name = column.name();
                    let value = if let Ok(v) = row.try_get::<String, _>(name) {
                        serde_json::Value::String(v)
                    } else if let Ok(v) = row.try_get::<i64, _>(name) {
                        serde_json::Value::Number(v.into())
                    } else if let Ok(v) = row.try_get::<f64, _>(name) {
                        serde_json::Number::from_f64(v)
                            .map(serde_json::Value::Number)
                            .unwrap_or(serde_json::Value::Null)
                    } else if let Ok(v) = row.try_get::<bool, _>(name) {
                        serde_json::Value::Bool(v)
                    } else if let Ok(v) = row.try_get::<chrono::NaiveDateTime, _>(name) {
                        serde_json::Value::String(v.to_string())
                    } else {
                        serde_json::Value::Null
                    };
                    map.insert(name.to_string(), value);
                }
                results.push(serde_json::Value::Object(map));
            }
            Json(serde_json::json!(results))
        }
        Err(e) => Json(serde_json::json!({ "error": e.to_string() })),
    }
}
// model.rs
use axum::extract::State;
use axum::Json;
use chrono::NaiveDateTime;
use serde::Serialize;
use sqlx::FromRow;
use sqlx::MySqlPool;

#[derive(Serialize, FromRow)]
pub struct User {
    #[sqlx(rename = "UserID")] // åŒ¹é…æ•°æ®åº“çš„å¤§å†™åˆ—å
    pub id: i32,
    #[sqlx(rename = "Username")]
    pub username: String,
    #[allow(dead_code)]
    #[serde(skip_serializing)] // æ•æ„Ÿä¿¡æ¯ä¸è¿”å›ç»™å‰ç«¯
    #[sqlx(rename = "Password")]
    pub password: String,
    #[sqlx(rename = "OrgID")]
    pub org_id: Option<i32>,
}

#[derive(Serialize, FromRow)]
pub struct Organization {
    #[sqlx(rename = "OrgID")]
    pub id: i32,
    #[sqlx(rename = "Name")]
    pub name: String,
    #[sqlx(rename = "ParentOrgID")]
    pub parent_id: Option<i32>,
    #[sqlx(rename = "LocationID")]
    pub location_id: i32,
}

#[derive(Serialize, FromRow)]
pub struct Submission {
    #[sqlx(rename = "SubmissionID")]
    pub id: i32,
    #[sqlx(rename = "UserID")]
    pub user_id: i32,
    #[sqlx(rename = "ProblemID")]
    pub problem_id: i32,
    #[sqlx(rename = "Result")]
    pub result: String,
    #[sqlx(rename = "SubmitTime")]
    pub submit_time: NaiveDateTime,
}

#[derive(Serialize, FromRow)]
pub struct Location {
    #[sqlx(rename = "LocationID")]
    pub id: i32,
    #[sqlx(rename = "LocationIP")]
    pub ip: String,
    #[sqlx(rename = "Address")]
    pub address: String,
}

#[derive(Serialize, FromRow)]
pub struct Problem {
    #[sqlx(rename = "ProblemID")]
    pub id: i32,
    #[sqlx(rename = "Description")]
    pub description: String,
    #[sqlx(rename = "TimeLimit")]
    pub time_limit: i32,
    #[sqlx(rename = "MemoryLimit")]
    pub memory_limit: i32,
}

#[derive(Serialize, FromRow)]
pub struct Tag {
    #[sqlx(rename = "TagID")]
    pub id: i32,
    #[sqlx(rename = "TagName")]
    pub tag_name: String,
}

#[derive(Serialize, FromRow)]
pub struct Contest {
    #[sqlx(rename = "ContestID")]
    pub id: i32,
    #[sqlx(rename = "ContestName")]
    pub contest_name: String,
    #[sqlx(rename = "StartTime")]
    pub start_time: Option<NaiveDateTime>,
    #[sqlx(rename = "EndTime")]
    pub end_time: Option<NaiveDateTime>,
}

#[derive(Serialize, FromRow)]
pub struct ContestParticipant {
    #[sqlx(rename = "ID")]
    pub id: i32,
    #[sqlx(rename = "ContestID")]
    pub contest_id: i32,
    #[sqlx(rename = "UserID")]
    pub user_id: i32,
}

#[derive(Serialize, FromRow)]
pub struct LoginLog {
    #[sqlx(rename = "LogID")]
    pub id: i32,
    #[sqlx(rename = "UserID")]
    pub user_id: i32,
    #[sqlx(rename = "LoginTime")]
    pub login_time: NaiveDateTime,
    #[sqlx(rename = "LocationID")]
    pub location_id: i32,
}

#[derive(Serialize, FromRow)]
pub struct ProblemTag {
    #[sqlx(rename = "ID")]
    pub id: i32,
    #[sqlx(rename = "ProblemID")]
    pub problem_id: i32,
    #[sqlx(rename = "TagID")]
    pub tag_id: i32,
}

#[derive(Serialize, FromRow)]
pub struct ContestProblemRelation {
    #[sqlx(rename = "ID")]
    pub id: i32,
    #[sqlx(rename = "ContestID")]
    pub contest_id: i32,
    #[sqlx(rename = "ProblemID")]
    pub problem_id: i32,
}

// è·å–æ‰€æœ‰ç”¨æˆ·
pub async fn get_users(State(pool): State<MySqlPool>) -> Json<serde_json::Value> {
    fetch_all_as::<User>(&pool, "SELECT * FROM User").await
}

// è·å–æ‰€æœ‰æœºæ„
pub async fn get_organizations(State(pool): State<MySqlPool>) -> Json<serde_json::Value> {
    fetch_all_as::<Organization>(&pool, "SELECT * FROM Organization").await
}

// è·å–æ‰€æœ‰æäº¤è®°å½•
pub async fn get_submissions(State(pool): State<MySqlPool>) -> Json<serde_json::Value> {
    fetch_all_as::<Submission>(&pool, "SELECT * FROM Submission").await
}

// è·å–æ‰€æœ‰é¢˜ç›®
pub async fn get_problems(State(pool): State<MySqlPool>) -> Json<serde_json::Value> {
    fetch_all_as::<Problem>(&pool, "SELECT * FROM Problem").await
}

// è·å–æ‰€æœ‰ä½ç½®
pub async fn get_locations(State(pool): State<MySqlPool>) -> Json<serde_json::Value> {
    fetch_all_as::<Location>(&pool, "SELECT * FROM Location").await
}

// è·å–æ‰€æœ‰ç«èµ›
pub async fn get_contests(State(pool): State<MySqlPool>) -> Json<serde_json::Value> {
    fetch_all_as::<Contest>(&pool, "SELECT * FROM Contest").await
}

// è·å–é¢˜ç›®æ ‡ç­¾å…³è”
pub async fn get_problem_tags(State(pool): State<MySqlPool>) -> Json<serde_json::Value> {
    fetch_all_as::<ProblemTag>(&pool, "SELECT * FROM ProblemTagRelation").await
}

pub async fn get_tags(State(pool): State<MySqlPool>) -> Json<serde_json::Value> {
    fetch_all_as::<Tag>(&pool, "SELECT * FROM Tag").await
}

pub async fn get_login_logs(State(pool): State<MySqlPool>) -> Json<serde_json::Value> {
    fetch_all_as::<LoginLog>(&pool, "SELECT * FROM LoginLog ORDER BY LoginTime DESC LIMIT 100").await
}

pub async fn get_contest_problem_relations(State(pool): State<MySqlPool>) -> Json<serde_json::Value> {
    fetch_all_as::<ContestProblemRelation>(&pool, "SELECT * FROM ContestProblemRelation").await
}

pub async fn get_contest_participants(State(pool): State<MySqlPool>) -> Json<serde_json::Value> {
    fetch_all_as::<ContestParticipant>(&pool, "SELECT * FROM ContestParticipant").await
}


// è¾…åŠ©å‡½æ•°ï¼šç»Ÿä¸€å¤„ç†é”™è¯¯å’Œåºåˆ—åŒ–
pub async fn fetch_all_as<T>(pool: &MySqlPool, sql: &str) -> Json<serde_json::Value>
where
    T: for<'r> sqlx::FromRow<'r, sqlx::mysql::MySqlRow> + Serialize + Send + Unpin,
{
    match sqlx::query_as::<_, T>(sql).fetch_all(pool).await {
        Ok(items) => Json(serde_json::json!(items)),
        Err(e) => Json(serde_json::json!({ "error": e.to_string() })),
    }
}
```

